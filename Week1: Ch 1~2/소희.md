# 1.1 웹 개발의 역사

## 1. 자바스크립트의 탄생

넷스케이프의 브랜드 아이크의 웹의 다양한 콘텐츠를 표현하기 위해 이미지, 플러그인 요소를 쉽게 조합할 수 있는 새로운 언어가 필요로 탄생하였다.

## 2. 자바스크립트 표준, ECMAScript의 탄생

경쟁 관계이던 넷스케피으와 마이크로소프트는 자신들의 브라우저에 새로운 기능을 빠르게 늘리기 시작했는데, 이렇게 추가된 기능은 각자의 브라우저에서만 동작했다.

특히 인터넷 익스플로러와 내비게이터의 DOM 구조는 완전히 다르기 때문에 브라우저마다 웹 페이지가 다르게 동작하거나 제대로 동작하지 않는 크로스 브라우징 이슈가 발생했다. 따라서 개발자는 어떤 기능을 추가하기 위해서는 두 개의 스크립트를 따로 개발해야 하는 어려움을 겪어야만 했다.

또한 초기의 자바스크립트는 브라우저 생태계를 고려해서 작성된 것이 아니었고 단지 새로운 기능이 추가되는 형태로 발전했다.

이에 따라 자바스크립트와 브라우저의 발전 속도 간의 차이가 나기 시작했고 결국 브라우저는 자바스크립트의 변화를 따라가지 못했다. 자바스크립트에 어떤 기능이 추가된다면 런타임 환경인 브라우저도 이 기능을 지원할 수 있어야 한다.

새로운 버전의 브라우저가 출시되어 자바스크립트의 새로운 기능을 지원하더라도 사용자가 예전 버전의 브라우저를 사용한다면 이 기능은 무용지물이 된다. 이런 문제를 해결하기 위해 자바스크립트에 폴리필(polyfill)과 트랜스파일(transpile)같은 개념이 등장하기도 했다.

<aside>
💡 **폴리필(polyfill)과 트랜스파일(transpile)**
폴리필은 브라우저가 지원하지 않는 코드를 브라우저에서 사용할 수 있도록 변환한 코드 조각이나 플러그인을 말한다. 트랜스파일은 최신 버전의 코드를 예전 버전의 코드로 변환하는 과정을 말한다. 
둘 다 최신 기능을 구버전의 실행 환경에서 동작할 수 있게 바꿔주는 역할을 한다. 유명한 폴리필 라이브러리로 core.js와 polyfill.io를 들 수 있으며 대표적인 트랜스파일러로는 바벨(babel)이 있다.

</aside>

넷스케이프는 컴퓨터 시스템의 표준을 관리하는 Ecma 인터내셔널(국제 표준화 기구)에 자바스크립트의 표준화를 위한 자바스크립트 기술 규격을 제출했고, Ecma 인터내셔널은 EC-MAScript라는 이름으로 자바스크립트 표준화를 공식화했다.

자바스크립트가 표준화되자 정적이던 웹사이트에서 동적인 웹 애플리케이션으로의 전환이 가속화되었다.

## 3. 웹사이트에서 웹 애플리케이션으로의 전환

### 웹사이트

웹사이트는 수집된 데이터 및 정보를 특정 페이지에 표시하기 위한 정적인 웹이다. 단방향으로 정보를 제공하기 때문에 사용자와 상호 작용하지 않으며, HTML에 링크가 연결된 웹 페이지 모음으로 콘텐츠가 동적으로 업데이트되지 않는다.

### 웹 애플리케이션

웹 애플리케이션은 사용자와 상호작용하는 쌍방향 소통의 웹을 말한다.

검색, 댓글, 채팅, 좋아요 기능 등 웹 페이지 내부에 수많은 애플리케이션이 동작하고 있기 때문에 웹 애플리케이션이라고 부른다.

대표적인 웹 애플리케이션이 구글 지도이다. 기존의 지도 서비스는 이미 만들어져 있느 지도를 브라우저가 다운로드해서 보여주는 형태였는데, 구글 지도는 길을 찾기 위해 사용자가 직접 출발지와 도착지를 입력할 수 있다는 점에서 쌍방향 소통이 가능한 웹 애플리케이션이다.

## 4. 개발 생태계의 발전

대규모 웹 서비스의 개발의 필요성이 커지고, 저마다의 디바이세으 최적화된 UX/UI를 기대하게 되면서 컴포넌트 베이스 개발(CBD) 방법론이 등장했다.

CBD는 서비스에서 다루는 데이터를 구분하고 그에 맞는 UI를 표현할 수 있게 컴포넌트 단위로 개발하는 접근 방식이다. (재사용할 수 잇는 컴포넌트를 개발 또는 조합해서 하나의 애플리케이션을 만드는 개발 방법론)

컴포넌트는 모듈과 유사하게 하나의 독립된 기능을 재사용하기 위한 코드 묶음이다. 다만 모듈과는 달리 런타임 환경에서 독립적으로 배포 및 실행될 수 있는 단위이다. 따라서 컴포넌트는 다른 컴포넌트와의 의존성을 최소화하거나 없애야 한다. 작은 기능을 가진 컴포넌트일수록 다른 컴포넌트에 의존하지 않고 독립적으로 존재할 수 있지만, 조합 과정에서 필연적으로 의존성이 생긴다.

의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성을 말한다. 따라서 개발자는 컴포넌트 간의 의존성을 파악해야 제대로 컴포넌트를 사용하고 변화에 대응할 수 있게 된다.

# 1.2 자바스크립트의 한계

## 1. 동적 타입 언어

자바스크립트 특징 중 하나가 동적 타입 언어라는 것이다. 이 말은 변수에 타입을 명시적으로 지정하지 않고 코드가 실행되는 런타임에 변숫값이 할당될 때 해당 값의 타입에 따라 변수 타입이 결정된다는 것을 의미한다.

## 2. 한계 극복을 위한 해결 방안

### JSDoc

- 모듈, 네임스페이스, 클래스, 메서드, 매개변수 등에 대한 API 문서 생성 도구다. 어디까지나 주석의 성격을 지니고 있기 때문에 강제성을 부여해 사용하기 어렵다는 단점이 있다.

### propTypes

- 리액트에서 컴포넌트 props의 타입을 검사하기 위해 사용하는 속성이다. 전체 애플리케이션의 타입 검사를 할 수 없고, 리액트라는 특정 라이브러리에서만 사용할 수 있다는 점에서 한계가 있다.

### 다트

- 자바슼릡트 대체 언어로 만들어졌다.

## 3. 타입스크립트의 등장

자바스크립트의 슈퍼셋 언어로 공개됐다.

<aside>
💡 **슈퍼셋(Superset)**
기존 언어에 새로운 기능과 문법을 추가해서 보완하거나 향상하는 것을 말한다. 슈퍼셋 언어는 기존 언어와 호환되며 일반적으로 컴파일러 등으로 기존 언어 코드로 변환되어 실행된다.

</aside>

- 안전성 보장: 정적 타이핑 제공
- 개발 생산성 향상: 변수와 함수 타입 추론 가능
- 협업에 유리: 인터페이스, 제네릭 등을 지원하여 코드 쉽게 파악
- 자바스크립트에 점진적으로 적용 가능

# 2.1 타입이란

## 1. 자료형으로서의 타입

모든 프로그래밍 언어는 변수를 선언하는 것부터 시작한다.

변수란 값을 저장할 수 있는 공간이자 값을 가리키는 상징적인 이름이다. 개발자는 변수를 선언하고 그 변수에 특정한 값인 데이터를 할당한다.

컴퓨터의 메모리 공간은 한정적이기 때문에, 특정 메모리에 값을 효율적으로 저장하기 위해서는 먼저 해당 메모리 공간을 차지할 값의 크기를 알아야 한다. 값의 크기를 명시한다면 컴퓨터가 값을 참조할 때 한 번에 읽을 메모리 크기를 알 수 있어 값을 훼손하지 않고 가져올 수 있다.

최신 ECMAScript 표준을 따르는 자바스크립트는 다음과 같은 7가지 데이터 타입(자료형)을 정의한다.

- undefined
- null
- Boolean
- String
- Symbol
- Numeric(Number과 BigInt)
- Object

이와 같은 유형을 데이터 타입 또는 자료형이라고 한다.

데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려준다. 메모리에 저장된 값을 데이터 타입으로 설명할 수 있으며 모든 데이터를 해석할 때 데이터 타입 체계가 사용된다.

메모리의 관점에서의 데이터 타입은 프로그래밍 언어에서 일반적으로 타입으로 부르는 개념과 같다. 개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있다.

## 2. 집합으로서의 타입

프로그래밍에서의 타입은 수학의 집합과 유사하다. 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

일단 타입을 제한하면 타입스크립트 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지 판단한다.

## 3. 정적 타입과 동적 타입

타입을 결정하는 시점에 따라 정적 타입(static type)과 동적 타입(dynamic type)으로 분류할 수 있다.

정적 타입 시스템에서는 모든 변수의 타입이 컴파일타임에 결정된다. 그러므로 프로그램의 안정성을 보장할 수 있다.

동적 타입 시스템에서는 변수 타입이 런타임에서 결정된다. 프로그램을 실행할 때 타입 에러가 발견되므로 언제 프로그램에 오류가 생길지 모르는 불안감에 휩싸이게 된다.

<aside>
💡 **컴파일타임과 런타임**
기계(컴퓨터, 엔진)가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점으 컴파일타임이라고 한다. 이후 변환된 파일이 메모리에 적재되어 실행되는 시점을 런타임이라고 한다.

</aside>

## 4. 강타입과 약타입

**암묵적 타입 변환**: 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것을 말한다.

암묵적 타입 변환 여부에 따라 타입 시스템을 강타입과 약타입으로 분류할 수 있다.

- 강타입: 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생한다.
- 약타입: 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출한다.

## 5. 컴파일 방식

컴파일은 서로 다른 수준(고수준-저수준) 간의 코드 변환을 의미한다.

타입스크립트의 컴파일 결과물은 여전히 사람이 이해할 수 있는 방식인 자바스크립트 파일이다.

자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위해 탄생했으므로, 타입스크립트를 컴파일하면 타입이 모두 제거된 자바스크립트 소스 코드만이 남게 된다.

# 2.2 타입스크립트의 타입 시스템

## 1. 타입 애너테이션 방식

타입 애너테이션(type annotation)이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다.

변수 이름 뒤에 : type 구문을 붙여 데이터 타입을 명시해준다.

```tsx
let color: string = "blue";
```

## 2. 구조적 타이핑

이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 타입스크립트는 구조로 타입을 구분한다. 이것을 구조적 타이핑이라고 한다.

```tsx
// 명목적으로 구체화한 타입 시스템
class Animal {
	String name;
	int age;
}

// 구조적 타이핑
interface Developer {
	faceValue: number;
}

interface BankNote {
	faceValue: number;
}

let developer: Developer
let bankNote: BankNote

developer = bankNote // true
```

## 3. 구조적 서브타이핑

타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 단지 집합에 포함된 값이고 특정 값은 많은 집합에 포함될 수 있다. 따라서 타입스크립트에서는 특정 값이 string 혹은 number 타입을 동시에 가질 수 있다.

```tsx
type stringOrNumber = string | number;
```

이처럼 집합으로 나타낼 수 있는 타입스크립트의 타입 시스템을 지탱하고 있는 개념이 구조적 서브타이핑이다.

**구조적 서브타이핑**: 객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것.

이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

```tsx
interface Pet {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

pet = cat; // ok
```

서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다. 타입 A가 타입 B의 서브타입이라면 A 타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다.

```tsx
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Person {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Persion) {
  console.log(`Hello, I'm ${p.name}`);
}

const develper = new Developer("zig", 20, 7);

greet(developer); // Hello, I'm zig
```

## 4. 자바스크립트를 닮은 타입스크립트

명목적 타이핑에서 두 변수는 같은 이름의 데이터 타입으로 선언된 경우에만 서로 호환된다. 이름으로 타입을 구분하기 때문에 구조가 같더라도이름이 다르다면 다른 타입으로 취급한다.

명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다. 개발자가 의도한 타입이 아니라면 변수에 타입을 명시하는 과정에서 에러를 내뱉기 때문이다. 즉, 객체의 속성을 다른 객체의 속성과 호환되지 않도록 하여 안전성을 추구한다.

그런데도 타입스크립트가 구조적 타이핑을 채택한 이유는 자바스크립트를 모델링한 언어이기 때문이다.

자바스크립트는 본질적으로 덕 타이핑을 기반으로 한다.

<aside>
💡 **덕 타이핑**
어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식이다.

</aside>

타입스크립트는 자바스크립트의 특징을 그대로 받아들여 명시적인 이름을 가지고 타입을 구분하는 대신 객체나 함수가 가진 구조적 특징을 기반으로 타이핑하는 방식을 택했다.

즉 객체가 가진 속성을 기반으로 타입을 검사한다.

덕 타이핑과 구조적 타이핑의 차이는 타입을 검사하는 시점이다.

덕 타이핑은 런타임에 타입을 검사하지만, 구조적 타이핑은 컴파일에 타입체커가 타입을 검사한다.

## 5. 구조적 타이핑의 결과

구조적 타이핑의특징으로 타입 값이 들어갈 곳에 추가 속성을 가진 객체도 할당할 수 있기 때문에 타입 에러가 발생할 수 있다.

이러한 한계를 극복하고자 타입스크립트에 명목적 타이핑 언어의 특징을 가미한 식별할 수 있는 유니온 같은 방법이 생겨났다.

## 6. 타입스크립트의 점진적 타입 확인

### any 타입

타입스크립트에서 any 타입은 타입스크립트 내 모든 타입의 종류를 포함하는 가장 상위 타입으로 어떤 타입 값이든 할당할 수 있다. 단, 타입스크립트 컴파일 옵션인 noImplicitAny 값이 true일 때는 에러가 발생한다. 타입 애너테이션이 없을 때 변수가 any 타입으로 추론되는 것을 허락하지 않는다.

타입스크립트로 코드를 작성할 때는 정확한 타이핑을 위해 tsconfig의 noImplicitAny 옵션을 true로 설정하는 게 좋다.

## 7. 자바스크립트 슈퍼셋으로서의 타입스크립트

## 8. 값 vs 타입

값: 프로그램에서 조작하고 다룰 수 있는 어떤 표현이며 다양한 형태의 데이터

값과 타입은 타입스크립트에서 별도의 네임스페이스에 존재한다.

타입스크립트에서는 값과 타입 공간에 동시에 존재하는 심볼도 있다. 대표적인 것이 클래스와 enum이다.

자바스크립트 ES6에서 등장한 클래스는 객체 인스턴스를 더욱 쉽게 생성하기 위한 문법 기능으로 실제 동작은 함수와 같다.

동시에 클래스는 타입으로도 사용된다. 즉 타입스크립트 코드에서 클래스는 값과 타입 공간 모두에 포함될 수 있다.

```tsx
class Developer {
  name: string;
  domain: string;

  constructor(name: string, domain: string) {
    this.name = name;
    this.domain = domain;
  }
}

const me: Developer = new Developer("zig", "frontend");
```

타입스크립트에서 클래스는 타입 애너테이션으로 사용할 수 있지만 런타임에서 객체로 변환되어 자바스크립트의 값으로 사용되는 특징을 가지고 있다.

클래스와 마찬가지로 타입스크립트 문법인 enum 역시 런타임에 객체로 변환되는 값이다.

enum은 런타임에 실제 객체로 존재하며, 함수로 표현할 수 있다.

```tsx
enum WeekDays {
	Mon = "Mon",
	...
}

type WeekDaysKey = keyof typeof WeekDays;

enum MyColors {
	BLUE = "#0000FF",
	MINT = "2Ac1BC"
	..
}

function whatMintColor(palette: {MINT: string }) {
	return palette.MINT;
}

whatMintColor(MyColors)
```

타입스크립트에서 어떠한 심볼이 값으로 사용된다는 것은 컴파일러를 사용해서 타입스크립트 파일을 자바스크립트 파일로 변환해도 여전히 자바스크립트 파일에 해당 정보가 남아있음을 의미한다.

## 9. 타입을 확인하는 방법

자바스크립트 내 클래스에서 instanceOf 연사자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있다. typeof 연산자처럼 instanceof 연산자의 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제하여 사용할 수 있다.

# type과 interface

TypeScript에서 `type`과 `interface`는 모두 타입을 정의하는 데 사용되지만, 각기 다른 특성과 사용 목적이 있습니다. 당신이 언급한 "선언 병합"과 "computed value"는 이 두 가지를 선택하는 데 중요한 요소입니다.

### 선언 병합 (Declaration Merging)

인터페이스는 TypeScript에서 선언 병합을 지원합니다. 이는 동일한 이름을 가진 여러 인터페이스 선언이 하나로 병합되는 것을 의미합니다. 이를 통해 여러 파일에 걸쳐 인터페이스를 확장하거나, 외부 라이브러리의 타입을 보강할 수 있습니다.

예시:

```tsx
typescript코드 복사
interface User {
  name: string;
}

interface User {
  age: number;
}

// 결과적으로 User 인터페이스는 다음과 같이 병합됩니다.
interface User {
  name: string;
  age: number;
}

```

### Computed Value (계산된 값)

`type` 정의는 유니언 타입, 교차 타입, 맵드 타입 등 다양한 고급 타입 구성을 지원하며, 계산된 값을 사용하는 경우 유용합니다. 계산된 값이란 타입이 프로그램 실행 시 동적으로 결정되는 것이 아니라, 타입 수준에서 다른 타입들을 조합하여 정의되는 것을 말합니다.

예시:

```tsx
typescript코드 복사
type Keys = 'name' | 'age';

type User = {
  [K in Keys]: string;
};

// 결과적으로 User 타입은 다음과 같이 정의됩니다.
type User = {
  name: string;
  age: string;
}

```

### 상황별 사용 예시

1.  **선언 병합이 필요할 때**
    인터페이스를 사용하면 여러 곳에서 동일한 이름의 인터페이스를 확장할 수 있어 유연합니다. 특히, 외부 라이브러리의 타입을 보강할 때 유용합니다.
        ```tsx
        typescript코드 복사
        interface Person {
          name: string;
        }

        // 다른 파일에서 같은 이름의 인터페이스에 추가 필드를 병합할 수 있습니다.
        interface Person {
          age: number;
        }

        ```
2.  **Computed Value가 필요할 때**
    맵드 타입이나 유니언 타입을 사용할 때는 `type` 정의가 더 적합합니다. 이는 복잡한 타입 변환이나 계산을 필요로 할 때 강력한 기능을 제공합니다.
        ```tsx
        typescript코드 복사
        type Status = 'success' | 'error';

        type Response = {
          [K in Status]: number;
        };
        // 결과: { success: number; error: number; }

        ```

### 결론

"선언 병합이 필요할 때는 인터페이스를 사용하고, 계산된 값을 사용해야 한다면 타입 정의를 쓴다"는 말은 다음과 같은 상황을 말합니다:

- **인터페이스:** 여러 선언을 하나로 병합해야 하거나, 구조적인 타입을 정의할 때 유용합니다.
- **타입 정의:** 맵드 타입, 유니언 타입 등 타입 조작이 필요할 때 강력한 기능을 제공합니다.
