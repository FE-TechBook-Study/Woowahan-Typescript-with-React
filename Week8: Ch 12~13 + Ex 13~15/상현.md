# 상현

## 12장. 타입스크립트 프로젝트 관리

### 12.1 엠비언트(Ambient) 타입

.d.ts 확장자를 가진 파일은 **타입 선언만** 할 수 있으며 일반적인 선언과 구별하기 위해 해당 확장자에서 선언을 앰비언트(Ambient) 타입 선언

**앱비언트의 활용 사례**

- 자바스크립트로 작성된 라이브러리: node_modules/@types 안에 있는 타입선언을 불러와서 타입 환경 설정
- 타입스크립트로 작성된 라이브러리: 일반적으로 자바스크립트 파일과 .d.ts 파일로 배포. 라이브러리 사용자 다시 컴파일하는 시간을 줄이기 위해서.

**주의점**

- tsconfig에서 `declaration : true`이면 굳이 작성할 필요 없음
- 동일한 이름의 앰비언트 타입끼리 충돌이 발생할 수 있음
- 한번 선언이 되면 프로젝트 어디에서든 전부 사용 가능
  - src/index.tsx에서 declare로 타입 선언 시, src/test.tsx에서 사용 가능

**활용하기**

- 타입을 정의하여 임포트 없이 전역으로 공유
- delcare type 활용. 보편적으로 많이 사용하며 전역에서 사용 가능
  ```tsx
  delcare type Nullable<T> = T | null;
  const name: Nullable<string> = "wowowowo"
  ```
- declare module 활용

  ```tsx
  const fontSizes = {
  	xl: "30px",
  	// ...
  }
  const theme = {
  	fontSizes,
  	// ..
  }

  delcare module "styled-components" {
  	type Theme = typeof theme;

  	export interface DefaultTheme extends Theme {}
  }
  ```

- delcare namespace 활용하기

  ```tsx
  // .env
  API_URL = "localhost:8000";

  declare namespace NodeJS {
    interface ProcessEnv {
      readonly API_URL: string;
    }
  }
  ```

- declare global 활용하기: 전역변수를 선언할 때 사용
  ```tsx
  declare global {
    interface Window {
      newProperty: string;
    }
  }
  ```

### 12.2 스크립트 설정 파일 활용하기

- 실시간 타입 검사: `tsc -noEmit -incremental -w`
- 타입 커버리지 활용: any타입의 위치 파악
- 컴파일 속도 높이기:`incremental` flag
- Restart TS server

### 12.3 타입스크립트 마이그레이션

- allowJs, noImplicitAny 등등 활용

### 12.4 모노레포

분산된 프로젝트에서 공통된 부분을 독립시켜서 재사용할 수 있다면 좋지만 그만큼 공통된 부분을 수정할 때 모든 프로젝트에서 전부 확인 필요

공통된 부분을 공통 모듈로 관리: npm으로 배포하여 프로젝트에 넣을 수 있지만 별도의 레포를 설정하고 Lint, 테스트, CI/CD 작성 필요.

모노레포를 통하여 공통된 모듈을 서로 공유하고, Lint 및 CI/CD 등 개발환경을 통합적으로 관리하기에 코드 중복 지향. 그러나, 프로젝트가 커질 수록 소유권과 권한 관리가 복잡해질 수 있기에 명확한 규정이 필요

## 13장. 타입스크립트와 객체 지향

타입스크립트는 점진적 타이핑, 구조적 타이핑, 덕 타이핑 결합

- 점진적 타이핑은 명시한 부분만 정적 타입 검사를 하고 나머지 부분은 동적 타입 검사
- 덕 타이핑은 객체의 변수와 메서드 집합이 객체의 타입을 결정
- 구조적 타이핑은 객체 속성에 해당하는 특정 타입의 속성을 갖는지를 검사하여 타입 호환성 결정

프론트에서 과연 적합할까? 어렵다

- 객체지향은 서로의 연관성을 먼저 파악하고 작성을 하지만 프론트 영역에서는 이 사항을 먼저 알아차리기 어렵다.

### 13.2 우아한형제들의 활용 방식

설계 방식

- 온전히 레이아웃만 담당하는 “컴포넌트 영역”
- 컴포넌트 영역 위에서 레이아웃과 비즈니스 로직을 연결해주는 “커스텀 훅 영역”
- 훅 영역 위에서 객체로소 상호 협력하는 “모델 영역”
- 모델 영역 위에서 API를 해석하여 모델로 전달하는 “API 레이어 영역”

### 13.3 캡슐화와 추상화

- 객체들이 좀 더 사람이 인지할 수 있도록 적합한(Cart, Product, Seller) 설계를 하는 것이 곧 “추상화”
- 프론트 관점에서 캡슐화란 내부 데이터인 상태와 props를 잘 다루는 것
  - props drilling이 심할 수록 캡슐화 저해. 적절하게 사용 필요

## TypeScript Exercise

```tsx
// 13
// This enables module augmentation mode.
import "date-wizard";

declare module "date-wizard" {
  // Add your module extensions here.
  interface DateDetails {
    hours: number;
    minutes: number;
    seconds: number;
  }
  function pad(s: number): string;
}
```

```tsx
// 14번(와 이건 진짜 모르겠다...)
/*

Intro:

    For some unknown reason most of our developers left
    the company. We need to actively hire now.
    In the media we've read that companies that invent
    and publish new technologies attract more potential
    candidates. We need to use this opportunity and
    invent and publish some npm packages. Following the
    new trend of functional programming in JS we
    decided to develop a functional utility library.
    This will put us on the bleading edge since we are
    pretty much sure no one else did anything similar.
    We also provided some jsdoc along with the
    functions, but it might sometimes be inaccurate.

Exercise:

    Provide proper typing for the specified functions.

Bonus:

    Could you please also refactor the code to reduce
    code duplication?
    You might need some excessive type casting to make
    it really short.

*/

function toFunctional<T extends Function>(func: T): Function {
  const fullArgCount = func.length;
  function createSubFunction(curriedArgs: unknown[]) {
    return function (this: unknown) {
      const newCurriedArguments = curriedArgs.concat(Array.from(arguments));
      if (newCurriedArguments.length > fullArgCount) {
        throw new Error("Too many arguments");
      }
      if (newCurriedArguments.length === fullArgCount) {
        return func.apply(this, newCurriedArguments);
      }
      return createSubFunction(newCurriedArguments);
    };
  }
  return createSubFunction([]);
}

interface MapperFunc<I, O> {
  (): MapperFunc<I, O>;
  (input: I[]): O[];
}

interface MapFunc {
  (): MapFunc;
  <I, O>(mapper: (item: I) => O): MapperFunc<I, O>;
  <I, O>(mapper: (item: I) => O, input: I[]): O[];
}

/**
 * 2 arguments passed: returns a new array
 * which is a result of input being mapped using
 * the specified mapper.
 *
 * 1 argument passed: returns a function which accepts
 * an input and returns a new array which is a result
 * of input being mapped using original mapper.
 *
 * 0 arguments passed: returns itself.
 */
export const map = toFunctional(<I, O>(fn: (arg: I) => O, input: I[]) =>
  input.map(fn)
) as MapFunc;

interface FiltererFunc<I> {
  (): FiltererFunc<I>;
  (input: I[]): I[];
}

interface FilterFunc {
  (): FilterFunc;
  <I>(filterer: (item: I) => boolean): FiltererFunc<I>;
  <I>(filterer: (item: I) => boolean, input: I[]): I[];
}

/**
 * 2 arguments passed: returns a new array
 * which is a result of input being filtered using
 * the specified filter function.
 *
 * 1 argument passed: returns a function which accepts
 * an input and returns a new array which is a result
 * of input being filtered using original filter
 * function.
 *
 * 0 arguments passed: returns itself.
 */
export const filter = toFunctional(<I,>(fn: (item: I) => boolean, input: I[]) =>
  input.filter(fn)
) as FilterFunc;

interface ReducerInitialFunc<I, O> {
  (): ReducerInitialFunc<I, O>;
  (input: I[]): O;
}

interface ReducerFunc<I, O> {
  (): ReducerFunc<I, O>;
  (initialValue: O): ReducerInitialFunc<I, O>;
  (initialValue: O, input: I[]): O;
}

interface ReduceFunc {
  (): ReduceFunc;
  <I, O>(reducer: (acc: O, val: I) => O): ReducerFunc<I, O>;
  <I, O>(reducer: (acc: O, val: I) => O, initialValue: O): ReducerInitialFunc<
    I,
    O
  >;
  <I, O>(reducer: (acc: O, val: I) => O, initialValue: O, input: I[]): O;
}

/**
 * 3 arguments passed: reduces input array it using the
 * specified reducer and initial value and returns
 * the result.
 *
 * 2 arguments passed: returns a function which accepts
 * input array and reduces it using previously specified
 * reducer and initial value and returns the result.
 *
 * 1 argument passed: returns a function which:
 *   * when 2 arguments is passed to the subfunction, it
 *     reduces the input array using specified initial
 *     value and previously specified reducer and returns
 *     the result.
 *   * when 1 argument is passed to the subfunction, it
 *     returns a function which expects the input array
 *     and reduces the specified input array using
 *     previously specified reducer and inital value.
 *   * when 0 argument is passed to the subfunction, it
 *     returns itself.
 *
 * 0 arguments passed: returns itself.
 */
export const reduce = toFunctional(
  <I, O>(reducer: (acc: O, item: I) => O, initialValue: O, input: I[]) =>
    input.reduce(reducer, initialValue)
) as ReduceFunc;

interface ArithmeticArgFunc {
  (): ArithmeticArgFunc;
  (b: number): number;
}

interface ArithmeticFunc {
  (): ArithmeticFunc;
  (a: number): ArithmeticArgFunc;
  (a: number, b: number): number;
}

/**
 * 2 arguments passed: returns sum of a and b.
 *
 * 1 argument passed: returns a function which expects
 * b and returns sum of a and b.
 *
 * 0 arguments passed: returns itself.
 */
export const add = toFunctional(
  (a: number, b: number) => a + b
) as ArithmeticFunc;

/**
 * 2 arguments passed: subtracts b from a and
 * returns the result.
 *
 * 1 argument passed: returns a function which expects
 * b and subtracts b from a and returns the result.
 *
 * 0 arguments passed: returns itself.
 */
export const subtract = toFunctional(
  (a: number, b: number) => a - b
) as ArithmeticFunc;

interface PropNameFunc<K extends string> {
  (): PropNameFunc<K>;
  <O extends { [key in K]: O[K] }>(obj: O): O[K];
}

interface PropFunc {
  (): PropFunc;
  <K extends string>(propName: K): PropNameFunc<K>;
  <O, K extends keyof O>(propName: K, obj: O): O[K];
}

/**
 * 2 arguments passed: returns value of property
 * propName of the specified object.
 *
 * 1 argument passed: returns a function which expects
 * propName and returns value of property propName
 * of the specified object.
 *
 * 0 arguments passed: returns itself.
 */
export const prop = toFunctional(
  <O, K extends keyof O>(obj: O, propName: K): O[K] => obj[propName]
) as PropFunc;

type F<A extends unknown[], R> = (...args: A) => R;
type TR<I, O> = (arg: I) => O;

interface PipeFunc {
  (): PipeFunc;
  <A1 extends unknown[], R1>(f: F<A1, R1>): (...args: A1) => R1;
  <A1 extends unknown[], R1, R2>(f: F<A1, R1>, tr1: TR<R1, R2>): (
    ...args: A1
  ) => R2;
  <A1 extends unknown[], R1, R2, R3>(
    f: F<A1, R1>,
    tr1: TR<R1, R2>,
    tr2: TR<R2, R3>
  ): (...args: A1) => R3;
  <A1 extends unknown[], R1, R2, R3, R4>(
    f: F<A1, R1>,
    tr1: TR<R1, R2>,
    tr2: TR<R2, R3>,
    tr3: TR<R3, R4>
  ): (...args: A1) => R4;
  <A1 extends unknown[], R1, R2, R3, R4, R5>(
    f: F<A1, R1>,
    tr1: TR<R1, R2>,
    tr2: TR<R2, R3>,
    tr3: TR<R3, R4>,
    tr4: TR<R4, R5>
  ): (...args: A1) => R5;
}

/**
 * >0 arguments passed: expects each argument to be
 * a function. Returns a function which accepts the
 * same arguments as the first function. Passes these
 * arguments to the first function, the result of
 * the first function passes to the second function,
 * the result of the second function to the third
 * function... and so on. Returns the result of the
 * last function execution.
 *
 * 0 arguments passed: returns itself.
 */
export const pipe: PipeFunc = function (...functions: Function[]) {
  if (arguments.length === 0) {
    return pipe;
  }
  return function subFunction() {
    let nextArguments = Array.from(arguments);
    let result;
    for (const func of functions) {
      result = func(...nextArguments);
      nextArguments = [result];
    }
    return result;
  };
};
```

```tsx
// 15(GPT랑 같이.... 강제 casting이 필요한지 몰랐...)
export class ObjectManipulator<T extends Record<string, any>> {
  constructor(protected obj: T) {}

  public set<K extends string, V>(
    key: K,
    value: V
  ): ObjectManipulator<T & Record<K, V>> {
    return new ObjectManipulator({ ...this.obj, [key]: value });
  }

  public get(key: keyof T) {
    return this.obj[key];
  }

  public delete<K extends keyof T>(key: K): ObjectManipulator<Omit<T, K>> {
    const newObj = { ...this.obj };
    delete newObj[key];
    return new ObjectManipulator(newObj as Omit<T, K>);
  }

  public getObject() {
    return this.obj;
  }
}
```

## 발표: **Declaration Merging**

| Declaration Type | Namespace | Type | Value |
| ---------------- | --------- | ---- | ----- |
| Namespace        | X         |      | X     |
| Class            |           | X    | X     |
| Enum             |           | X    | X     |
| Interface        |           | X    |       |
| Type Alias       |           | X    |       |
| Function         |           |      | X     |
| Variable         |           |      | X     |

### **Interface Merge**

```tsx
/** interface merge */
interface Box {
  height: number;
  width: number;
}
interface Box {
  scale: number;
}
let box: Box = { height: 5, width: 6, scale: 10 };

// 함수 interface
interface Cloner {
  clone(animal: Animal): Animal;
}
interface Cloner {
  clone(animal: Sheep): Sheep;
}
interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
}
// 나중에 선언된 것이 merge되었을 때 위로 올라옴
interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
  clone(animal: Sheep): Sheep;
  clone(animal: Animal): Animal;
}

// 예외 케이스: single string literal type가 제일 위로
interface Document {
  createElement(tagName: any): Element;
}
interface Document {
  createElement(tagName: "div"): HTMLDivElement;
  createElement(tagName: "span"): HTMLSpanElement;
}
interface Document {
  createElement(tagName: string): HTMLElement;
  createElement(tagName: "canvas"): HTMLCanvasElement;
}
interface Document {
  createElement(tagName: "canvas"): HTMLCanvasElement;
  createElement(tagName: "div"): HTMLDivElement;
  createElement(tagName: "span"): HTMLSpanElement;
  createElement(tagName: string): HTMLElement;
  createElement(tagName: any): Element;
}
```

### Namespace Merging

```tsx
namespace Animals {
  export class Zebra {}
}
namespace Animals {
  export interface Legged {
    numberOfLegs: number;
  }
  export class Dog {}
}

// 위는 아래와 같이 인식
namespace Animals {
  export interface Legged {
    numberOfLegs: number;
  }
  export class Zebra {}
  export class Dog {}
}

// namespace는 값 존재 가능
// namespace에서 export되지 않은 것은 다른 곳에서 사용 불가능
namespace Animal {
  let haveMuscles = true;
  export function animalsHaveMuscles() {
    return haveMuscles;
  }
}
namespace Animal {
  export function doAnimalsHaveMuscles() {
    return haveMuscles; // Error, because haveMuscles is not accessible here
  }
}
```

### Module Augmentation

```tsx
// observable.ts
export class Observable<T> {
  // ... implementation left as an exercise for the reader ...
}
// map.ts
import { Observable } from "./observable";
declare module "./observable" {
  interface Observable<T> {
    map<U>(f: (x: T) => U): Observable<U>;
  }
}
Observable.prototype.map = function (f) {
  // ... another exercise for the reader
};
// consumer.ts
import { Observable } from "./observable";
import "./map";
let o: Observable<number>;
o.map((x) => x.toFixed());

// 위 방법의 두 가지 제한
// 1. 기존 선언에 대해서 추가만 가능.
// 2. default export는 불가. named export만 가능

/** Global Augmentation 가능 */
// observable.ts
export class Observable<T> {
  // ... still no implementation ...
}
declare global {
  interface Array<T> {
    toObservable(): Observable<T>;
  }
}
Array.prototype.toObservable = function () {
  // ...
};
```

번외로 궁금해서 GPT와 함께 공부한 namespace, module, global의 차이점

- namespace는 그룹화 기능
  ```tsx
  declare namespace React {
    // Keep in sync with JSX namespace in ./jsx-runtime.d.ts and ./jsx-dev-runtime.d.ts
    namespace JSX {
      type ElementType = GlobalJSXElementType;
      interface Element extends GlobalJSXElement {}
      interface ElementClass extends GlobalJSXElementClass {}
      interface ElementAttributesProperty
        extends GlobalJSXElementAttributesProperty {}
      interface ElementChildrenAttribute
        extends GlobalJSXElementChildrenAttribute {}

      type LibraryManagedAttributes<C, P> = GlobalJSXLibraryManagedAttributes<
        C,
        P
      >;

      interface IntrinsicAttributes extends GlobalJSXIntrinsicAttributes {}
      interface IntrinsicClassAttributes<T>
        extends GlobalJSXIntrinsicClassAttributes<T> {}
      interface IntrinsicElements extends GlobalJSXIntrinsicElements {}
    }
  }
  ```
- global은 말 그대로 전역 선언이 되어서 프로젝트 전체에서 접근 가능
  ```tsx
  // global.d.ts
  declare global {
    var myGlobalVar: string;
  }

  // main.ts
  myGlobalVar = "Hello, world!";
  console.log(myGlobalVar); // Hello, world!
  ```
- module은 기존의 기능에서 확장을 유용
  ```tsx
  // observable.ts
  export class Observable<T> {
    // ... implementation left as an exercise for the reader ...
  }
  // map.ts
  import { Observable } from "./observable";
  // 아래 declare module을 통해서 observable 내부에 새로운 함수 추가 및 확장
  declare module "./observable" {
    interface Observable<T> {
      map<U>(f: (x: T) => U): Observable<U>;
    }
  }
  Observable.prototype.map = function (f) {
    // ... another exercise for the reader
  };
  // consumer.ts
  import { Observable } from "./observable";
  import "./map";
  let o: Observable<number>;
  o.map((x) => x.toFixed());
  ```
