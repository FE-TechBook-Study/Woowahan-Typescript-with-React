# 12 타입스크립트 프로젝트 관리

# 12.1 앰비언트 타입 선언

타입스크립트의 타입 선언은 `.ts` 또는 `.tsx` 확장자를 가진 파일에서 할 수 있지만 `.d.ts` 확장자를 가진 파일에서도 선언할 수 있다.

### `.d.ts` (TypeScript Declaration File)

- 타입 선언 파일이다.
- JavaScript 라이브러리나 모듈의 타입 정의를 명시할 때 사용된다.
- 코드 구현 없이 타입만을 정의하여 TypeScript가 해당 모듈을 이해하도록 돕는다.
- 주로 라이브러리의 타입 정보를 제공하거나, 외부 모듈의 타입을 정의할 때 사용된다.

## 1. 앰비언트 타입 선언

타입 선언 파일에서는 타입 선언만 할수 있으며 값을 표현할 수 없다.

값을 포함하는 일반적인 선언과 구별하기 위해 `.d.ts` 확장자를 가진 파일에서 하는 타입 선언을 앰비언트 타입 선언이라고 부른다.

`declare` 키워드를 사용하여 정의하며, 기존 JavasScript 코드나 외부 패키지의타입을 명확히 설명해주는 역할을 한다.

값을 정의할 수는 없지만 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있다.

`delcare` 는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할을 한다. 단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아니다.

```tsx

// node_modules/@types/react/index.d.ts
declare namespace React {
    //
    // React Elements
    // ----------------------------------------------------------------------

    /**
     * Used to retrieve the possible components which accept a given set of props.
     *
     * Can be passed no type parameters to get a union of all possible components
     * and tags.
     *
     * Is a superset of {@link ComponentType}.

```

React도 `declare` 키워드를 사용하여 타입 선언이 되어 있다.

### 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용한다.

예를 들어 웹뷰를 개발할 때 네이티브 앱과의 통신을 위한 인터페이스를 네이트브 앱이 Window 객체에 추가하는 경우가 많다.

이렇게 전역 객체인 Window에 변수나 함수를 추가하면 타입스크립트에서 직접 구현하지 않았더라도 실제 런타임 환경에서 해당 변수를 사용할 수 있다.

네이트브 앱에서 Window 전역 객체에 deviceId나 appVersion 같은 값을 할당해주는 시나리오를 떠올려 보자.

Window 객체의 속성은 타입스크립트로 직접 정의한 값이 아니기 때문에 타입스크립트는 해당 속성이 WIndow 객체의 타입에 존재하지 않는다고 판단한다.

따라서 해당 속성에 접근하려고 하면 Window 객체에 존재하지 않는 속성이라는 에러가 발생한다.

이때 global namespace 에 있는 Window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 사용할 수 있다.

```tsx
declare global {
  interface Window {
    deviceId: string;
    appVersion: string;
  }
}

// 실제 코드 파일에서 아래와 같이 접근
if (window.deviceId) {
  console.log(`Device ID: ${window.deviceId}`);
}

if (window.appVersion) {
  console.log(`App Version: ${window.appVersion}`);
}
```

위의 같이 실제 런타임 환경에서 존재함을 타입스크립트에게 알려주기 위해 앰비언트 타입 선언을 사용한다.

타입스크립트 컴파일러는 해당 속성들이 존재함을 인지하고 오류를 발생시키지 않도록 할 수 있다.

## 2. 앰비언트 타입 선언 시 주의점

### 타입스크립트로 만드는 라이브러리에는 불필요

`tsconfig.json`의 `declaration` 을 `true` 로 설정하면 타입스크립트 컴파일러가 `.d.ts` 파일을 자동으로 생성해주기 때문에 수동으로 `.d.ts` 파일을 작성할 필요가 없다.

따라서 타입스크립트로 라이브러리를 개발할 때는 앰비언트 타입 선언을 사용할 필요가 없다.

### 전역으로 타입을 정의하여 사용할 때 주의해야 할 점

서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용될지 알기 어려우며, 의도한 대로 동작하지 않을 수 있다.

또한, 앰비언트 타입 선언은 명시적 임포트나 익스포트가 없기 때문에 코드의 의존성 관계가 명확하지 않아 나중에변경할 때 어려움을 겪을 수 있다.

## 3. 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

`.ts` 파일 내부에 앰비언트 변수를 선언할 때 앰비언트 타입의 의존성 관계가 보이지 않기 때문에 변경에 의한 영향 범위를 파악하기 어렵다.

소스코드 규모가 커진다면 추후 변경이 어려워질 수 있다.

`A.tsx` 에 선언된 앰비언트 타입은 `B.tsx` 파일에서도 임포트 없이 사용할 수 있다.

이처럼 어느 곳에나 영향을 줄 수 있기 때문에 일반 타입 선언과 섞이게 되면 앰비언트 선언이 어떤 파일에 포함되어 있는지 파악하기 어려워진다.

`.d.ts` 확장자 파일 내에서 앰비언트 타입 선언을 하는 것은 일종의 개발자 간의 약속이다.

타입 선언 위치가 명확해야 가독성이 높아지고 유지보수도 편하게 할 수 있기 때문이다.

## 4. 앰비언트 타입 활용하기

### 타입을 정의하여 임포트 없이 전역으로 공유

`.d.ts` 파일에서의 앰비언트 타입 선언을 전역 변수와 같은 역할을 한다.

따라서 앰비언트 타입을 선언하면 모든 코드 내에서 임포트하지 않고 사용할 수 있다.

유용한 유틸리티 타입을 작성했다고 가정하면, 마치 내장 타입 유틸리티 함수를 사용하는 것처럼 사용할 수 있다.

### declare type 활용하기

많이 사용하는 커스텀 유틸리티 타입을 `delcare type` 으로 선언하여 전역에서 사용할 수 있다.

```tsx
declare type Nullable<T> = T | null;

const name: Nullable<string> = "woowa";
```

### declare module 활용하기

다음과 같이 모듈로 인식하여 사용할 수 있게끔 만들 수 있다.

```tsx
declare module "styled-components" {
  type Theme = typeof theme;

  export interface DefaultTheme extends Theme {}
}

declare module "*.gif" {
  const src: string;

  export default src;
}
```

### declare namespace 활용하기

Node.js 환경에서 `.env` 파일을 사용할 때, `declare namespace` 를 활용하여 process.env로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.

```tsx
declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
    readonly API_INTERNAL_URL: string;
  }
}
```

### declare global 활용하기

전역 변수를 선언할 때 사용한다. 예를 들어 전역 변수인 Window 객체의 스코프에서 사용되는 모듈이나 변수를 추가할 수 있다.

## 5. declare와 번돌러의 시너지

`declare global` 로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.

다음과 같이 전역에 \_color 라는 변수가 존재함을 타입스크립트 컴파일러에 알리면 해당 객체를 활용할 수 있다.

아직 ColorSet 타입을 가지고 있는 \_color 객체의 실제 데이터가 존재하지 않는다.

다시 말해 앞의 코드는 타입스크립트 에러를 발생시키지 않지만, 코드가 실행될 경우에는 실제 데이터가 없기 때문에 기대하는 동작과 다를 수 있다.

이러한 문제를 해결하기 위한 방법 중 하나가 번들 시점에 번들러를 통해서 해당 데이터를 주입하는 것이다.

```tsx
// data.ts
export const color = {
  primary: "#ffffff",
  secondary: "#000000",
};

// type.ts
declare global {
  interface Window {
    _color: ColorSet;
  }

  interface ColorSet {
    primary: string;
    secondary: string;
  }
}

// index.ts
console.log(_color["primary"]);
```

```tsx
// rollup.config.js
import inject from "@rollup/plugin-inject";

export default {
  input: "src/index.ts",
  output: {
    file: "dist/bundle.js",
    format: "esm",
  },
  plugins: [
    typescript(),
    inject({
      _color: ["./data", "color"],
    }),
  ],
};
```

코드 설명:

`data.ts` 에서 색상을 정의하고 있으며 `type.ts` 에서는 해당 데이터로부터 타입을 정의하여 전역적으로 선언하고 있다.

`index.ts` 파일에서는 전역 타입으로 선언된 변수인 `_color['white']` 를 콘솔로 출력하고 있다.

그리고 가장 중요한 롤업 번들러 설정에서 inject 모듈을 사용하여 `_color` 에 해당하는 데이터를 삽입하고 있다.

- 추가 설명(GPT)
  `declare`를 통해 타입스크립트에서 전역 변수의 **타입**을 정의할 수는 있지만, 실제 **값**을 할당하거나 변수를 생성하는 것은 아닙니다. 이로 인해 타입스크립트는 해당 변수가 존재한다고 인식하지만, **런타임**에서는 실제 값이 없어서 오류가 발생할 수 있습니다.
  따라서 번들러(예: Rollup)의 `inject` 플러그인을 사용하여, `data.ts`의 실제 **데이터를 전역 변수에 주입**함으로써 런타임 시점에서도 `_color`라는 변수가 정의되고 값을 가지게 되는 것입니다.

# 12.2 스크립트와 설정 파일 활용하기

## 1. 스크립트 활용하기

### 실시간으로 타입을 검사하자

아래 스크립트를 사용하여 실시간으로 에러를 확인할 수 있다.

`yarn tsx --noEmit --incremental -w`

- noEmit: 자바스크립트로 된 출력 파일을 생성하지 않도록 한다.
- incremental: 증분 컴파일(변경 사항만 컴파일)을 활성화하여 컴파일 시간을 단축할 수 있게 해준다.
- w: 파일 변경 사항을 모니터링 한다.

### 타입 커버리지 확인하기

아래 스크립트를 사용하여 현재 프로젝트의 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타난다.

`npx type-coverage --detail`

타입스크립트로 마이그레이션 중인 프로젝트를 다룰 때 타입 커버리지를 체크함으로써 정량적인 지표를 얻을 수 있다.

## 2. 설정 파일 활용하기

### 타입스크립트 컴파일 속도 높이기

`tsconfig` 의 `incremental` 속성을 활용하여 타입스크립트 컴파일 속도를 높일 수 있다.

`incremental` 속성을 `true` 로 설정하면 증분 컴파일이 활성화되어 변경된 부분만 컴파일 한다.

```tsx
// tsconfig
{
	'compilerOptions': {
		...
		incremental: true
	}
}
```

# 13 타입스크립트와 객체 지향

# 13.1 타입스크립트의 객체 지향

자바스크립트도 객체 지향 프로그래밍을 할 수 있다.

자바스크립트는 프로토타입 기반의 객체 지향 언어로 분류된다. 그러나, 전통적인 객체 지향 프로그래밍 언어에서 기대할 수 있는 일부 기능을 지원하지 않아 객체 지향을 온전히 구현하는데 부족함이 있다.

이러한 제약을 타입스크립트가 private와 같은 접근 제어자나 추상 클래스, 추상 메서드 같은 기능을 지원하면서 해결해준다.

타입스크립트는 객체 지향을 구현할 수 있도록 도와주는 자바스크립트의 슈퍼셋으로 볼 수 있다.

타입스크립트는 점진적 타이핑, 구조적 타이핑 그리고 덕 타이핑이 결합한 언어이다.

- 점진적 타이핑은 프로그램 전체가 아닌 개발자가 명시한 일부분만 정적 타입 검사를 거치게 하고 나머지 부분은 그대로 동적 타입 검사가 이루어지게 하여 점진적 개선을 할수 있도록 한다.
- 덕 타이핑은 객체의 변수와 메서드 집함이 객체의 타입을 결정하게 해준다.
- 구조적 타이핑을 구조적 타입 시스템이라고도 부른다. 명시적인 선언이나 이름에 의존하여 명확한 상속 관계를 지향하는 노미널 타이핑과 달리, 구조적 타이핑은 객체의 속성에 해당하는 특정 타입의 속성을 갖는지를 검사하여 타입 호환성을 결정한다.

타입스크립트 같은 구조적 타이핑 언어는 하나의 클래스에 여러 인터페이스가 연결될 수 있으며, 하나의 인터페이스에 여러 클래스가 연결될 수도 있다.

어떻게 프론트엔드에서 객체 지향을 효과적으로 활용할 수 있을까?

회사의 전략과 프로젝트의 방향성에 따라 다양한 접근 방식이 있을 것이다.

특히 레이아웃은 예상치 못한 변동 사항이 생길 가능성이 높기 때문에 미확정 여역으로 두고 공통으로 사용되는 컴포넌트와 비즈니스 영역에서 객체 지향 원칙을 적용하여 설계하면 좋은 구조를 개발할 수 있을 것이다.

# 13.2 우아한형제들의 활용 방식

우아한형제들 한 팀에서의 설계 방식

- 온전히 레이아웃만 담당하는 컴포넌트 영역
- 컴포넌트 영역 위에서 레이아웃과 비즈니스 로직을 연결해주는 커스텀 훅 영역
- 훅 영역 위에서 객체로서 상호 협력하는 모델 영역
- 모델 영역 위에서 API를 해석하여 모델로 전달하는 API 레이어 영역

# 13.3 캡슐화와 추상화

프로젝트 설계의 궁극적인 목표는 객체들이 유기적으로 협력하게끔 만들어서 적절하게 도메인 분리를 하는 것이다.

이를 위해 캡슐화는 중요한 도구가 될 수 있다.

추상화도 별것이 아니다.

객체들을 모델링하는 과정 자체가 추상화다.

이 객체들을 좀 더 사람이 인지할 수 있도록 적합한 설계를 하는 것이 곧 추상화다.

캡슐화란 다른 객체 내부의 데이터를 꺼내와서 직접 다루지 않고, 해당 객체에서 처리할 행위를 따로 요청함으로써 협력하는 것이다.

프론트엔드 관점에서 쉽게 생각해보자.

컴포넌트는 객체다.

그렇다면 컴포넌트의 내부 데이터인 상태(state)가 바로 캡슐화의 대상이 될 수 있다.

결국 컴포넌트 내의 상태와 prop을 잘 다루느 것도 캡슐화의 개념에 부합하는 것이다.

prop drilling이 심할수록 컴포넌트 간의 결합도는 높아지며 내부 처리 로직이 외부로 드러나기 마련이다.

즉, prop drilling은 좋지 못한 관계를 형성하게 하고 캡슐화를 저해한다.

이런 문제를 해결하기 위해 옵저버 패턴이 등장했으며 나아가 컨텍스트 API 및 Redux, MobX, Recoil 과 같은 다양한 상태 관리 라이브러리가 생겨났다.

적절하게 캡슐화하고 추상화된 컴포넌트를 활용하면 애플리케이션을 더 유기적으로 구성할 수 있다.

최종적인 우리의 지향점은 객체들이 유기적으로 협력하게끔 해서 올바르게 도메인을 분리하는 것이다.
