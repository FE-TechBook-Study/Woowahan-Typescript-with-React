# 12 타입스크립트 프로젝트 관리

# 12.1 앰비언트 타입 선언

타입스크립트의 타입 선언은 `.ts` 또는 `.tsx` 확장자를 가진 파일에서 할 수 있지만 `.d.ts` 확장자를 가진 파일에서도 선언할 수 있다.

### `.d.ts` (TypeScript Declaration File)

- 타입 선언 파일이다.
- JavaScript 라이브러리나 모듈의 타입 정의를 명시할 때 사용된다.
- 코드 구현 없이 타입만을 정의하여 TypeScript가 해당 모듈을 이해하도록 돕는다.
- 주로 라이브러리의 타입 정보를 제공하거나, 외부 모듈의 타입을 정의할 때 사용된다.

## 1. 앰비언트 타입 선언

타입 선언 파일에서는 타입 선언만 할수 있으며 값을 표현할 수 없다.

값을 포함하는 일반적인 선언과 구별하기 위해 `.d.ts` 확장자를 가진 파일에서 하는 타입 선언을 앰비언트 타입 선언이라고 부른다.

`declare` 키워드를 사용하여 정의하며, 기존 JavasScript 코드나 외부 패키지의타입을 명확히 설명해주는 역할을 한다.

값을 정의할 수는 없지만 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있다.

`delcare` 는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할을 한다. 단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아니다.

```tsx

// node_modules/@types/react/index.d.ts
declare namespace React {
    //
    // React Elements
    // ----------------------------------------------------------------------

    /**
     * Used to retrieve the possible components which accept a given set of props.
     *
     * Can be passed no type parameters to get a union of all possible components
     * and tags.
     *
     * Is a superset of {@link ComponentType}.

```

React도 `declare` 키워드를 사용하여 타입 선언이 되어 있다.

### 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용한다.

예를 들어 웹뷰를 개발할 때 네이티브 앱과의 통신을 위한 인터페이스를 네이트브 앱이 Window 객체에 추가하는 경우가 많다.

이렇게 전역 객체인 Window에 변수나 함수를 추가하면 타입스크립트에서 직접 구현하지 않았더라도 실제 런타임 환경에서 해당 변수를 사용할 수 있다.

네이트브 앱에서 Window 전역 객체에 deviceId나 appVersion 같은 값을 할당해주는 시나리오를 떠올려 보자.

Window 객체의 속성은 타입스크립트로 직접 정의한 값이 아니기 때문에 타입스크립트는 해당 속성이 WIndow 객체의 타입에 존재하지 않는다고 판단한다.

따라서 해당 속성에 접근하려고 하면 Window 객체에 존재하지 않는 속성이라는 에러가 발생한다.

이때 global namespace 에 있는 Window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 사용할 수 있다.

```tsx
declare global {
  interface Window {
    deviceId: string;
    appVersion: string;
  }
}

// 실제 코드 파일에서 아래와 같이 접근
if (window.deviceId) {
  console.log(`Device ID: ${window.deviceId}`);
}

if (window.appVersion) {
  console.log(`App Version: ${window.appVersion}`);
}
```

위의 같이 실제 런타임 환경에서 존재함을 타입스크립트에게 알려주기 위해 앰비언트 타입 선언을 사용한다.

타입스크립트 컴파일러는 해당 속성들이 존재함을 인지하고 오류를 발생시키지 않도록 할 수 있다.

## 2. 앰비언트 타입 선언 시 주의점

### 타입스크립트로 만드는 라이브러리에는 불필요

`tsconfig.json`의 `declaration` 을 `true` 로 설정하면 타입스크립트 컴파일러가 `.d.ts` 파일을 자동으로 생성해주기 때문에 수동으로 `.d.ts` 파일을 작성할 필요가 없다.

따라서 타입스크립트로 라이브러리를 개발할 때는 앰비언트 타입 선언을 사용할 필요가 없다.

### 전역으로 타입을 정의하여 사용할 때 주의해야 할 점

서로 다른 라이브러리에서 동일한 이름의 앰비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용될지 알기 어려우며, 의도한 대로 동작하지 않을 수 있다.

또한, 앰비언트 타입 선언은 명시적 임포트나 익스포트가 없기 때문에 코드의 의존성 관계가 명확하지 않아 나중에변경할 때 어려움을 겪을 수 있다.

## 3. 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

`.ts` 파일 내부에 앰비언트 변수를 선언할 때 앰비언트 타입의 의존성 관계가 보이지 않기 때문에 변경에 의한 영향 범위를 파악하기 어렵다.

소스코드 규모가 커진다면 추후 변경이 어려워질 수 있다.

`A.tsx` 에 선언된 앰비언트 타입은 `B.tsx` 파일에서도 임포트 없이 사용할 수 있다.

이처럼 어느 곳에나 영향을 줄 수 있기 때문에 일반 타입 선언과 섞이게 되면 앰비언트 선언이 어떤 파일에 포함되어 있는지 파악하기 어려워진다.

`.d.ts` 확장자 파일 내에서 앰비언트 타입 선언을 하는 것은 일종의 개발자 간의 약속이다.

타입 선언 위치가 명확해야 가독성이 높아지고 유지보수도 편하게 할 수 있기 때문이다.

## 4. 앰비언트 타입 활용하기

### 타입을 정의하여 임포트 없이 전역으로 공유

`.d.ts` 파일에서의 앰비언트 타입 선언을 전역 변수와 같은 역할을 한다.

따라서 앰비언트 타입을 선언하면 모든 코드 내에서 임포트하지 않고 사용할 수 있다.

유용한 유틸리티 타입을 작성했다고 가정하면, 마치 내장 타입 유틸리티 함수를 사용하는 것처럼 사용할 수 있다.

### declare type 활용하기

많이 사용하는 커스텀 유틸리티 타입을 `delcare type` 으로 선언하여 전역에서 사용할 수 있다.

```tsx
declare type Nullable<T> = T | null;

const name: Nullable<string> = "woowa";
```

### declare module 활용하기

다음과 같이 모듈로 인식하여 사용할 수 있게끔 만들 수 있다.

```tsx
declare module "styled-components" {
  type Theme = typeof theme;

  export interface DefaultTheme extends Theme {}
}

declare module "*.gif" {
  const src: string;

  export default src;
}
```

### declare namespace 활용하기

Node.js 환경에서 `.env` 파일을 사용할 때, `declare namespace` 를 활용하여 process.env로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.

```tsx
declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
    readonly API_INTERNAL_URL: string;
  }
}
```

### declare global 활용하기

전역 변수를 선언할 때 사용한다. 예를 들어 전역 변수인 Window 객체의 스코프에서 사용되는 모듈이나 변수를 추가할 수 있다.

## 5. declare와 번돌러의 시너지

`declare global` 로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.

다음과 같이 전역에 \_color 라는 변수가 존재함을 타입스크립트 컴파일러에 알리면 해당 객체를 활용할 수 있다.

아직 ColorSet 타입을 가지고 있는 \_color 객체의 실제 데이터가 존재하지 않는다.

다시 말해 앞의 코드는 타입스크립트 에러를 발생시키지 않지만, 코드가 실행될 경우에는 실제 데이터가 없기 때문에 기대하는 동작과 다를 수 있다.

이러한 문제를 해결하기 위한 방법 중 하나가 번들 시점에 번들러를 통해서 해당 데이터를 주입하는 것이다.

```tsx
// data.ts
export const color = {
  primary: "#ffffff",
  secondary: "#000000",
};

// type.ts
declare global {
  interface Window {
    _color: ColorSet;
  }

  interface ColorSet {
    primary: string;
    secondary: string;
  }
}

// index.ts
console.log(_color["primary"]);
```

```tsx
// rollup.config.js
import inject from "@rollup/plugin-inject";

export default {
  input: "src/index.ts",
  output: {
    file: "dist/bundle.js",
    format: "esm",
  },
  plugins: [
    typescript(),
    inject({
      _color: ["./data", "color"],
    }),
  ],
};
```

코드 설명:

`data.ts` 에서 색상을 정의하고 있으며 `type.ts` 에서는 해당 데이터로부터 타입을 정의하여 전역적으로 선언하고 있다.

`index.ts` 파일에서는 전역 타입으로 선언된 변수인 `_color['white']` 를 콘솔로 출력하고 있다.

그리고 가장 중요한 롤업 번들러 설정에서 inject 모듈을 사용하여 `_color` 에 해당하는 데이터를 삽입하고 있다.

- 추가 설명(GPT)
  `declare`를 통해 타입스크립트에서 전역 변수의 **타입**을 정의할 수는 있지만, 실제 **값**을 할당하거나 변수를 생성하는 것은 아닙니다. 이로 인해 타입스크립트는 해당 변수가 존재한다고 인식하지만, **런타임**에서는 실제 값이 없어서 오류가 발생할 수 있습니다.
  따라서 번들러(예: Rollup)의 `inject` 플러그인을 사용하여, `data.ts`의 실제 **데이터를 전역 변수에 주입**함으로써 런타임 시점에서도 `_color`라는 변수가 정의되고 값을 가지게 되는 것입니다.

# 12.2 스크립트와 설정 파일 활용하기

## 1. 스크립트 활용하기

### 실시간으로 타입을 검사하자

아래 스크립트를 사용하여 실시간으로 에러를 확인할 수 있다.

`yarn tsx --noEmit --incremental -w`

- noEmit: 자바스크립트로 된 출력 파일을 생성하지 않도록 한다.
- incremental: 증분 컴파일(변경 사항만 컴파일)을 활성화하여 컴파일 시간을 단축할 수 있게 해준다.
- w: 파일 변경 사항을 모니터링 한다.

### 타입 커버리지 확인하기

아래 스크립트를 사용하여 현재 프로젝트의 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타난다.

`npx type-coverage --detail`

타입스크립트로 마이그레이션 중인 프로젝트를 다룰 때 타입 커버리지를 체크함으로써 정량적인 지표를 얻을 수 있다.

## 2. 설정 파일 활용하기

### 타입스크립트 컴파일 속도 높이기

`tsconfig` 의 `incremental` 속성을 활용하여 타입스크립트 컴파일 속도를 높일 수 있다.

`incremental` 속성을 `true` 로 설정하면 증분 컴파일이 활성화되어 변경된 부분만 컴파일 한다.

```tsx
// tsconfig
{
	'compilerOptions': {
		...
		incremental: true
	}
}
```

# 13 타입스크립트와 객체 지향

# 13.1 타입스크립트의 객체 지향

자바스크립트도 객체 지향 프로그래밍을 할 수 있다.

자바스크립트는 프로토타입 기반의 객체 지향 언어로 분류된다. 그러나, 전통적인 객체 지향 프로그래밍 언어에서 기대할 수 있는 일부 기능을 지원하지 않아 객체 지향을 온전히 구현하는데 부족함이 있다.

이러한 제약을 타입스크립트가 private와 같은 접근 제어자나 추상 클래스, 추상 메서드 같은 기능을 지원하면서 해결해준다.

타입스크립트는 객체 지향을 구현할 수 있도록 도와주는 자바스크립트의 슈퍼셋으로 볼 수 있다.

타입스크립트는 점진적 타이핑, 구조적 타이핑 그리고 덕 타이핑이 결합한 언어이다.

- 점진적 타이핑은 프로그램 전체가 아닌 개발자가 명시한 일부분만 정적 타입 검사를 거치게 하고 나머지 부분은 그대로 동적 타입 검사가 이루어지게 하여 점진적 개선을 할수 있도록 한다.
- 덕 타이핑은 객체의 변수와 메서드 집함이 객체의 타입을 결정하게 해준다.
- 구조적 타이핑을 구조적 타입 시스템이라고도 부른다. 명시적인 선언이나 이름에 의존하여 명확한 상속 관계를 지향하는 노미널 타이핑과 달리, 구조적 타이핑은 객체의 속성에 해당하는 특정 타입의 속성을 갖는지를 검사하여 타입 호환성을 결정한다.

타입스크립트 같은 구조적 타이핑 언어는 하나의 클래스에 여러 인터페이스가 연결될 수 있으며, 하나의 인터페이스에 여러 클래스가 연결될 수도 있다.

어떻게 프론트엔드에서 객체 지향을 효과적으로 활용할 수 있을까?

회사의 전략과 프로젝트의 방향성에 따라 다양한 접근 방식이 있을 것이다.

특히 레이아웃은 예상치 못한 변동 사항이 생길 가능성이 높기 때문에 미확정 여역으로 두고 공통으로 사용되는 컴포넌트와 비즈니스 영역에서 객체 지향 원칙을 적용하여 설계하면 좋은 구조를 개발할 수 있을 것이다.

# 13.2 우아한형제들의 활용 방식

우아한형제들 한 팀에서의 설계 방식

- 온전히 레이아웃만 담당하는 컴포넌트 영역
- 컴포넌트 영역 위에서 레이아웃과 비즈니스 로직을 연결해주는 커스텀 훅 영역
- 훅 영역 위에서 객체로서 상호 협력하는 모델 영역
- 모델 영역 위에서 API를 해석하여 모델로 전달하는 API 레이어 영역

# 13.3 캡슐화와 추상화

프로젝트 설계의 궁극적인 목표는 객체들이 유기적으로 협력하게끔 만들어서 적절하게 도메인 분리를 하는 것이다.

이를 위해 캡슐화는 중요한 도구가 될 수 있다.

추상화도 별것이 아니다.

객체들을 모델링하는 과정 자체가 추상화다.

이 객체들을 좀 더 사람이 인지할 수 있도록 적합한 설계를 하는 것이 곧 추상화다.

캡슐화란 다른 객체 내부의 데이터를 꺼내와서 직접 다루지 않고, 해당 객체에서 처리할 행위를 따로 요청함으로써 협력하는 것이다.

프론트엔드 관점에서 쉽게 생각해보자.

컴포넌트는 객체다.

그렇다면 컴포넌트의 내부 데이터인 상태(state)가 바로 캡슐화의 대상이 될 수 있다.

결국 컴포넌트 내의 상태와 prop을 잘 다루느 것도 캡슐화의 개념에 부합하는 것이다.

prop drilling이 심할수록 컴포넌트 간의 결합도는 높아지며 내부 처리 로직이 외부로 드러나기 마련이다.

즉, prop drilling은 좋지 못한 관계를 형성하게 하고 캡슐화를 저해한다.

이런 문제를 해결하기 위해 옵저버 패턴이 등장했으며 나아가 컨텍스트 API 및 Redux, MobX, Recoil 과 같은 다양한 상태 관리 라이브러리가 생겨났다.

적절하게 캡슐화하고 추상화된 컴포넌트를 활용하면 애플리케이션을 더 유기적으로 구성할 수 있다.

최종적인 우리의 지향점은 객체들이 유기적으로 협력하게끔 해서 올바르게 도메인을 분리하는 것이다.

---

# type expercise

## 13

**요구 사항**

- `date-wizard` 라이브러리 제공하는 `DateDetails` 타입 내 hours, minutes, seconds가 빠져있음.
  → 시간 관련 필드 추가해야함.
- `pad` 함수가 export 되어 있지만 선언은 안되어있음.
  - 라이브러리 내부에는 함수가 존재하는데, 해당 함수에 대한 타입 선언이 안되어있음.
  - `pad` 함수의 인풋과 아웃풋 타입을 추론하기 위해서는 타입 선언 필요함.

**해결 방법**

`declare module` 로 모듈 타입을 확장 및 수정한다.

- **모듈의 타입을 확장하거나 수정**할 때 사용함.
- **기존의 타입 선언이 불완전**하거나 **추가적인 타입 정보가 필요할 때** 해당 모듈에 대한 타입을 새롭게 선언하거나 보완할 수 있도록 하기 위해 존재함.
- `declare module`을 통해 모듈을 확장해서 타입을 보완함.

**문제 풀이 전**

```tsx
// This enables module augmentation mode.
import "date-wizard";

declare module "date-wizard" {
  // Add your module extensions here.
}
```

**문제 풀이 후**

```tsx
// This enables module augmentation mode.
import "date-wizard";

declare module "date-wizard" {
  // Add your module extensions here.

  export function pad(s: number): string;

  export interface DateDetails {
    hours: number;
    minutes: number;
    seconds: number;
  }
}
```

## 14

**요구 사항**

- **`map`** :
  - **2개의 인자**가 주어지면: 주어진 배열을 주어진 **매핑 함수**로 변환한 새 배열을 반환해야 한다.
  - **1개의 인자**가 주어지면: 입력을 받아서 매핑 함수로 배열을 변환하는 **함수를 반환**해야 한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
- **`filter` 함수**:
  - **2개의 인자**가 주어지면: 주어진 배열을 **필터링 함수**로 걸러낸 새 배열을 반환해야 한다.
  - **1개의 인자**가 주어지면: 입력을 받아 필터링하는 **함수를 반환**해야 한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
- **`reduce` 함수**:
  - **3개의 인자**가 주어지면: 배열을 **리듀스 함수와 초기값**으로 축약한 결과를 반환한다.
  - **2개의 인자**가 주어지면: 배열을 받아 리듀스 함수를 적용하는 **함수를 반환**한다.
  - **1개의 인자**가 주어지면: 초기값과 배열을 받아 축약하는 **함수를 반환**해야 한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
- **`add`와 `subtract` 함수**:
  - **2개의 인자**가 주어지면: 각각 **덧셈** 또는 **뺄셈의 결과**를 반환한다.
  - **1개의 인자**가 주어지면: 두 번째 인자를 받아 계산을 수행하는 **함수를 반환**한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
- **`prop` 함수**:
  - **2개의 인자**가 주어지면: 객체의 **주어진 속성 값**을 반환한다.
  - **1개의 인자**가 주어지면: 속성명을 받아 값을 반환하는 **함수를 반환**한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
- **`pipe` 함수**:
  - 0개 이상의 함수가 인자로 전달되며, **각 함수의 실행 결과가 다음 함수의 인자로 전달**됩니다.
  - 함수들이 체인처럼 연결되어 마지막 함수의 실행 결과를 반환해야 한다.
  - **0개의 인자**가 주어지면: **자기 자신을 반환**해야 한다.
  - **5개의 함수**까지 처리할 수 있어야 하며, 각 함수의 반환 타입과 다음 함수의 인자 타입이 호환되어야 한다.

<aside>
💡

**arguments**

자바스크립트의 기본 제공 객체로, 함수 내부에서 함수에 전달된 모든 인자들의 유사 배열을 가리킨다.
즉, 함수에 몇 개의 인자가 전달되었는지와 그 값을 전급할 수 있는 객체이다.

function(함수 선언문)에서만 접근 가능하기 때문에,
화살표 함수로 매개변수 접근시, `...args` 형태로 유사하게 처리할 수 있다.

```tsx
function example(a, b) {
  console.log(arguments[0]); // a의 값
  console.log(arguments[1]); // b의 값
  console.log(arguments.length); // 전달된 인자의 개수
}
```

```tsx
const example = (...args) => {
	console.log(args[0]); // a의 값
	console.log(args[1]); // b의 값
	console.log(args.length); // 전달된 인자의 개수
```

</aside>

**해결 방법**

- 모든 함수들의 공통점은 인자의 갯수에 따라 조건부 처리를 한다.
- 인풋(A)과 계산 함수(fn)를 받아, 아웃풋(B)을 반환한다.
- 이를 모듈화한 함수를 만들어 중복되는 로직을 줄인다.

---

해결책으로 **커링(Currying)이라는 함수형 프로그래밍 기법이 사용됐다.**

- 하나의 함수가 여러 인자를 나눠서 받는 형태로 구현되는 것을 말한다.
- 인자를 **하나씩 나누어 전달**할 수 있기 때문에, 함수를 동적으로 조합하거나 재사용할 때 유리하다.
- 커링을 통해 **부분 적용(Partial Application)**이 가능해지며, 기존에 정의한 함수를 쉽게 재활용할 수 있다.
- 커링
  **커링**이란:
  - 여러 개의 인자를 한 번에 받는 대신, **하나의 인자만 받아서 반환된 함수가 나머지 인자를 계속 받는 방식**이다.
  - 이렇게 하면 **부분 적용(Partial Application)**이 가능해져서 함수의 인자를 **나눠서 처리**할 수 있다.
  - `add` 함수의 이부 인자만 먼저 제공하고, 나중에 남은 인자 제공 가능.
    ```tsx
    const add = (a: number) => (b: number) => a + b;

    const addFive = add(5); // b를 받는 함수를 반환
    console.log(addFive(10)); // 출력: 15
    ```
- **문제 풀이 전 (코드가 길어 토글 처리)**
  ```tsx
  /*
  
  Intro:
  
      For some unknown reason most of our developers left
      the company. We need to actively hire now.
      In the media we've read that companies that invent
      and publish new technologies attract more potential
      candidates. We need to use this opportunity and
      invent and publish some npm packages. Following the
      new trend of functional programming in JS we
      decided to develop a functional utility library.
      This will put us on the bleading edge since we are
      pretty much sure no one else did anything similar.
      We also provided some jsdoc along with the
      functions, but it might sometimes be inaccurate.
  
  Exercise:
  
      Provide proper typing for the specified functions.
  
  Bonus:
  
      Could you please also refactor the code to reduce
      code duplication?
      You might need some excessive type casting to make
      it really short.
  
  */

  /**
   * 2 arguments passed: returns a new array
   * which is a result of input being mapped using
   * the specified mapper.
   *
   * 1 argument passed: returns a function which accepts
   * an input and returns a new array which is a result
   * of input being mapped using original mapper.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Function} mapper
   * @param {Array} input
   * @return {Array | Function}
   */
  export function map(mapper, input) {
    if (arguments.length === 0) {
      return map;
    }
    if (arguments.length === 1) {
      return function subFunction(subInput) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return subInput.map(mapper);
      };
    }
    return input.map(mapper);
  }

  /**
   * 2 arguments passed: returns a new array
   * which is a result of input being filtered using
   * the specified filter function.
   *
   * 1 argument passed: returns a function which accepts
   * an input and returns a new array which is a result
   * of input being filtered using original filter
   * function.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Function} filterer
   * @param {Array} input
   * @return {Array | Function}
   */
  export function filter(filterer, input) {
    if (arguments.length === 0) {
      return filter;
    }
    if (arguments.length === 1) {
      return function subFunction(subInput) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return subInput.filter(filterer);
      };
    }
    return input.filter(filterer);
  }

  /**
   * 3 arguments passed: reduces input array it using the
   * specified reducer and initial value and returns
   * the result.
   *
   * 2 arguments passed: returns a function which accepts
   * input array and reduces it using previously specified
   * reducer and initial value and returns the result.
   *
   * 1 argument passed: returns a function which:
   *   * when 2 arguments is passed to the subfunction, it
   *     reduces the input array using specified initial
   *     value and previously specified reducer and returns
   *     the result.
   *   * when 1 argument is passed to the subfunction, it
   *     returns a function which expects the input array
   *     and reduces the specified input array using
   *     previously specified reducer and inital value.
   *   * when 0 argument is passed to the subfunction, it
   *     returns itself.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Function} reducer
   * @param {*} initialValue
   * @param {Array} input
   * @return {* | Function}
   */
  export function reduce(reducer, initialValue, input) {
    if (arguments.length === 0) {
      return reduce;
    }
    if (arguments.length === 1) {
      return function subFunction(subInitialValue, subInput) {
        if (arguments.length === 0) {
          return subFunction;
        }
        if (arguments.length === 1) {
          return function subSubFunction(subSubInput) {
            if (arguments.length === 0) {
              return subSubFunction;
            }
            return subSubInput.reduce(reducer, subInitialValue);
          };
        }
        return subInput.reduce(reducer, subInitialValue);
      };
    }
    if (arguments.length === 2) {
      return function subFunction(subInput) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return subInput.reduce(reducer, initialValue);
      };
    }
    return input.reduce(reducer, initialValue);
  }

  /**
   * 2 arguments passed: returns sum of a and b.
   *
   * 1 argument passed: returns a function which expects
   * b and returns sum of a and b.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Number} a
   * @param {Number} b
   * @return {Number | Function}
   */
  export function add(a, b) {
    if (arguments.length === 0) {
      return add;
    }
    if (arguments.length === 1) {
      return function subFunction(subB) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return a + subB;
      };
    }
    return a + b;
  }

  /**
   * 2 arguments passed: subtracts b from a and
   * returns the result.
   *
   * 1 argument passed: returns a function which expects
   * b and subtracts b from a and returns the result.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Number} a
   * @param {Number} b
   * @return {Number | Function}
   */
  export function subtract(a, b) {
    if (arguments.length === 0) {
      return subtract;
    }
    if (arguments.length === 1) {
      return function subFunction(subB) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return a - subB;
      };
    }
    return a - b;
  }

  /**
   * 2 arguments passed: returns value of property
   * propName of the specified object.
   *
   * 1 argument passed: returns a function which expects
   * propName and returns value of property propName
   * of the specified object.
   *
   * 0 arguments passed: returns itself.
   *
   * @param {Object} obj
   * @param {String} propName
   * @return {* | Function}
   */
  export function prop(obj, propName) {
    if (arguments.length === 0) {
      return prop;
    }
    if (arguments.length === 1) {
      return function subFunction(subPropName) {
        if (arguments.length === 0) {
          return subFunction;
        }
        return obj[subPropName];
      };
    }
    return obj[propName];
  }

  /**
   * >0 arguments passed: expects each argument to be
   * a function. Returns a function which accepts the
   * same arguments as the first function. Passes these
   * arguments to the first function, the result of
   * the first function passes to the second function,
   * the result of the second function to the third
   * function... and so on. Returns the result of the
   * last function execution.
   *
   * 0 arguments passed: returns itself.
   *
   * TODO TypeScript
   *   * Should properly handle at least 5 arguments.
   *   * Should also make sure argument of the next
   *     function matches the return type of the previous
   *     function.
   *
   * @param {Function[]} functions
   * @return {*}
   */
  export function pipe(...functions) {
    if (arguments.length === 0) {
      return pipe;
    }
    return function subFunction() {
      let nextArguments = Array.from(arguments);
      let result;
      for (const func of functions) {
        result = func(...nextArguments);
        nextArguments = [result];
      }
      return result;
    };
  }
  ```
- **문제 풀이 후**
  - 문제 풀이에서는 `func`에 필요한 모든 인자가 전달될 때까지, 부분적으로 함수를 반환한다.
  - `createSubFunctio`\*은 현재까지 받은 인자들을 누적하고, 인자가 충분하면 함수를 실행한다. 그렇지 않으면 **다시 커링된 함수를 반환한다.**
  ```tsx
  /*
  
  Intro:
  
      For some unknown reason most of our developers left
      the company. We need to actively hire now.
      In the media we've read that companies that invent
      and publish new technologies attract more potential
      candidates. We need to use this opportunity and
      invent and publish some npm packages. Following the
      new trend of functional programming in JS we
      decided to develop a functional utility library.
      This will put us on the bleading edge since we are
      pretty much sure no one else did anything similar.
      We also provided some jsdoc along with the
      functions, but it might sometimes be inaccurate.
  
  Exercise:
  
      Provide proper typing for the specified functions.
  
  Bonus:
  
      Could you please also refactor the code to reduce
      code duplication?
      You might need some excessive type casting to make
      it really short.
  
  */

  function toFunctional<T extends Function>(func: T): Function {
    const fullArgCount = func.length;
    function createSubFunction(curriedArgs: unknown[]) {
      return function (this: unknown) {
        const newCurriedArguments = curriedArgs.concat(Array.from(arguments));
        if (newCurriedArguments.length > fullArgCount) {
          throw new Error("Too many arguments");
        }
        if (newCurriedArguments.length === fullArgCount) {
          return func.apply(this, newCurriedArguments);
        }
        return createSubFunction(newCurriedArguments);
      };
    }
    return createSubFunction([]);
  }

  interface MapperFunc<I, O> {
    (): MapperFunc<I, O>;
    (input: I[]): O[];
  }

  interface MapFunc {
    (): MapFunc;
    <I, O>(mapper: (item: I) => O): MapperFunc<I, O>;
    <I, O>(mapper: (item: I) => O, input: I[]): O[];
  }

  /**
   * 2 arguments passed: returns a new array
   * which is a result of input being mapped using
   * the specified mapper.
   *
   * 1 argument passed: returns a function which accepts
   * an input and returns a new array which is a result
   * of input being mapped using original mapper.
   *
   * 0 arguments passed: returns itself.
   */
  export const map = toFunctional(<I, O>(fn: (arg: I) => O, input: I[]) =>
    input.map(fn)
  ) as MapFunc;

  interface FiltererFunc<I> {
    (): FiltererFunc<I>;
    (input: I[]): I[];
  }

  interface FilterFunc {
    (): FilterFunc;
    <I>(filterer: (item: I) => boolean): FiltererFunc<I>;
    <I>(filterer: (item: I) => boolean, input: I[]): I[];
  }

  /**
   * 2 arguments passed: returns a new array
   * which is a result of input being filtered using
   * the specified filter function.
   *
   * 1 argument passed: returns a function which accepts
   * an input and returns a new array which is a result
   * of input being filtered using original filter
   * function.
   *
   * 0 arguments passed: returns itself.
   */
  export const filter = toFunctional(
    <I,>(fn: (item: I) => boolean, input: I[]) => input.filter(fn)
  ) as FilterFunc;

  interface ReducerInitialFunc<I, O> {
    (): ReducerInitialFunc<I, O>;
    (input: I[]): O;
  }

  interface ReducerFunc<I, O> {
    (): ReducerFunc<I, O>;
    (initialValue: O): ReducerInitialFunc<I, O>;
    (initialValue: O, input: I[]): O;
  }

  interface ReduceFunc {
    (): ReduceFunc;
    <I, O>(reducer: (acc: O, val: I) => O): ReducerFunc<I, O>;
    <I, O>(reducer: (acc: O, val: I) => O, initialValue: O): ReducerInitialFunc<
      I,
      O
    >;
    <I, O>(reducer: (acc: O, val: I) => O, initialValue: O, input: I[]): O;
  }

  /**
   * 3 arguments passed: reduces input array it using the
   * specified reducer and initial value and returns
   * the result.
   *
   * 2 arguments passed: returns a function which accepts
   * input array and reduces it using previously specified
   * reducer and initial value and returns the result.
   *
   * 1 argument passed: returns a function which:
   *   * when 2 arguments is passed to the subfunction, it
   *     reduces the input array using specified initial
   *     value and previously specified reducer and returns
   *     the result.
   *   * when 1 argument is passed to the subfunction, it
   *     returns a function which expects the input array
   *     and reduces the specified input array using
   *     previously specified reducer and inital value.
   *   * when 0 argument is passed to the subfunction, it
   *     returns itself.
   *
   * 0 arguments passed: returns itself.
   */
  export const reduce = toFunctional(
    <I, O>(reducer: (acc: O, item: I) => O, initialValue: O, input: I[]) =>
      input.reduce(reducer, initialValue)
  ) as ReduceFunc;

  interface ArithmeticArgFunc {
    (): ArithmeticArgFunc;
    (b: number): number;
  }

  interface ArithmeticFunc {
    (): ArithmeticFunc;
    (a: number): ArithmeticArgFunc;
    (a: number, b: number): number;
  }

  /**
   * 2 arguments passed: returns sum of a and b.
   *
   * 1 argument passed: returns a function which expects
   * b and returns sum of a and b.
   *
   * 0 arguments passed: returns itself.
   */
  export const add = toFunctional(
    (a: number, b: number) => a + b
  ) as ArithmeticFunc;

  /**
   * 2 arguments passed: subtracts b from a and
   * returns the result.
   *
   * 1 argument passed: returns a function which expects
   * b and subtracts b from a and returns the result.
   *
   * 0 arguments passed: returns itself.
   */
  export const subtract = toFunctional(
    (a: number, b: number) => a - b
  ) as ArithmeticFunc;

  interface PropNameFunc<K extends string> {
    (): PropNameFunc<K>;
    <O extends { [key in K]: O[K] }>(obj: O): O[K];
  }

  interface PropFunc {
    (): PropFunc;
    <K extends string>(propName: K): PropNameFunc<K>;
    <O, K extends keyof O>(propName: K, obj: O): O[K];
  }

  /**
   * 2 arguments passed: returns value of property
   * propName of the specified object.
   *
   * 1 argument passed: returns a function which expects
   * propName and returns value of property propName
   * of the specified object.
   *
   * 0 arguments passed: returns itself.
   */
  export const prop = toFunctional(
    <O, K extends keyof O>(obj: O, propName: K): O[K] => obj[propName]
  ) as PropFunc;

  type F<A extends unknown[], R> = (...args: A) => R;
  type TR<I, O> = (arg: I) => O;

  interface PipeFunc {
    (): PipeFunc;
    <A1 extends unknown[], R1>(f: F<A1, R1>): (...args: A1) => R1;
    <A1 extends unknown[], R1, R2>(f: F<A1, R1>, tr1: TR<R1, R2>): (
      ...args: A1
    ) => R2;
    <A1 extends unknown[], R1, R2, R3>(
      f: F<A1, R1>,
      tr1: TR<R1, R2>,
      tr2: TR<R2, R3>
    ): (...args: A1) => R3;
    <A1 extends unknown[], R1, R2, R3, R4>(
      f: F<A1, R1>,
      tr1: TR<R1, R2>,
      tr2: TR<R2, R3>,
      tr3: TR<R3, R4>
    ): (...args: A1) => R4;
    <A1 extends unknown[], R1, R2, R3, R4, R5>(
      f: F<A1, R1>,
      tr1: TR<R1, R2>,
      tr2: TR<R2, R3>,
      tr3: TR<R3, R4>,
      tr4: TR<R4, R5>
    ): (...args: A1) => R5;
  }

  /**
   * >0 arguments passed: expects each argument to be
   * a function. Returns a function which accepts the
   * same arguments as the first function. Passes these
   * arguments to the first function, the result of
   * the first function passes to the second function,
   * the result of the second function to the third
   * function... and so on. Returns the result of the
   * last function execution.
   *
   * 0 arguments passed: returns itself.
   */
  export const pipe: PipeFunc = function (...functions: Function[]) {
    if (arguments.length === 0) {
      return pipe;
    }
    return function subFunction() {
      let nextArguments = Array.from(arguments);
      let result;
      for (const func of functions) {
        result = func(...nextArguments);
        nextArguments = [result];
      }
      return result;
    };
  };
  ```

## 15

**요구 사항**

- `ObjectManipulator` 클래스는 **객체를 조작하기 위한 작은 라이브러리**.
  - **`set(key, value)`**: 객체에 새로운 속성을 추가하거나 기존 속성의 값을 업데이트한다.
  - **`get(key)`**: 특정 속성의 값을 가져온다.
  - **`delete(key)`**: 객체에서 특정 속성을 삭제한다.
  - **`getObject()`**: 현재 객체를 반환한다.

**해결 방법**

- 객체 타입을 추적하기 위해 클래스에 제네릭 타입 매개변수(T)를 추가한다.
- 메서드 타입 안정성 보장하기 위해 서, 각 입력 값과 반환 타입 명시해준다.

**문제 풀이 전**

```tsx
export class ObjectManipulator {
  // Parameter 'obj' implicitly has an 'any' type.(7006)
  constructor(protected obj) {}

  // Parameter 'key' implicitly has an 'any' type.(7006)
  // Parameter 'value' implicitly has an 'any' type.(7006)
  public set(key, value) {
    return new ObjectManipulator({ ...this.obj, [key]: value });
  }

  // Parameter 'key' implicitly has an 'any' type.(7006)
  public get(key) {
    return this.obj[key];
  }

  // Parameter 'key' implicitly has an 'any' type.(7006)
  public delete(key) {
    const newObj = { ...this.obj };
    delete newObj[key];
    return new ObjectManipulator(newObj);
  }

  public getObject() {
    return this.obj;
  }
}
```

**문제 풀이 후**

- `extends` 로 제네릭 타입을 사용하면 타입 범위를 좁혀주고, 안전하게 타입 추론이 되도록 한다.

```tsx
type WithNewProperty<T, K extends string, V> = T & Record<K, V>;

export class ObjectManipulator<T> {
  constructor(protected obj: T) {}

  public set<K extends string, V>(
    key: K,
    value: V
  ): ObjectManipulator<WithNewProperty<T, K, V>> {
    return new ObjectManipulator({
      ...this.obj,
      [key]: value,
    } as WithNewProperty<T, K, V>);
  }

  public get<K extends keyof T>(key: K): T[K] {
    return this.obj[key];
  }

  public delete<K extends keyof T>(key: K): ObjectManipulator<Omit<T, K>> {
    const newObj = { ...this.obj };
    delete newObj[key];
    return new ObjectManipulator(newObj);
  }

  public getObject(): T {
    return this.obj;
  }
}
```

**궁금했던 점**

Q. 테스트 코드에서는 제네릭 타입을 명시적으로 지정하지 않음에도 부룩하고, 어덯게 제네릭이 클래스에 적용되는걸까?

A. 타입스크립트의 타입 추론 때문이다.

- 타입 추론:
  - 타입스크립트가 제공된 값과 문맥을 기반으로 제네릭 타입 매개변수를 자동으로 추론한다.
  - 마치 React의 `useState` 매개변수 기반으로 state가 자동추론 되듯이!
    ```tsx
    function useState<S>(
      initialState: S | (() => S)
    ): [S, Dispatch<SetStateAction<S>>];
    ```
    ![스크린샷 2024-10-12 21.17.36.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/e81c09f3-53c7-4b3e-a68a-1f4de827a594/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-12_21.17.36.png)

```tsx
const test1 = new ObjectManipulator({}) // 여기서 T는 {}로 추론된다.
  .set("x", 123) // K는 'x', V는 number로 추론된다.
  .set("y", "hello")
  .getObject();
```

**자동 추론 vs 명시적 타입 지정**

| **상황**                                | **자동 추론 가능**     | **제네릭 필요**            |
| --------------------------------------- | ---------------------- | -------------------------- |
| 초기값이 명확한 경우                    | ✅                     | ❌                         |
| 초기값이 없거나 `undefined`로 시작할 때 | ❌                     | ✅                         |
| 반환값이 동적이거나 런타임에 결정될 때  | ❌                     | ✅                         |
| 객체나 배열 등 구조가 복잡한 경우       | ✅ (초기값이 명확하면) | 상황에 따라 필요할 수 있음 |
