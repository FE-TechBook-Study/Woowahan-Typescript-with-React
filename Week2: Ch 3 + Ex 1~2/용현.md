# 용현

# 3장. 고급 타입

## 3.1 타입스크립트만의 독자적 타입 시스템

### 3.1.1 any 타입

- any 타입은 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다.
- 타입을 명시하지 않는 것과 동일한 효과.
- 타입스크립트에서 any 타입을 어쩔 수 없이 사용해야 할 때
  - 개발 단계에서 임시로 값을 지정해야 할 때
  - 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
  - 값을 예측할 수 없을 때 암묵적으로 사용

### 3.1.2 unknown 타입

- unknown 타입은 any 타입과 유사하게 모든 타입의 값이 할당될 수 있다.
- 그러나 any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.
- unknown 타입은 이름처럼 무엇이 할당될지 아직 모르는 상태의 타입을 말한다.

### 3.1.3 void 타입

- 함수가 어떤 값을 반환하지 않는 경우에는 void를 지정하여 사용한다고 생각하면 된다.

### 3.1.4 never 타입

- never 타입은 값을 반환할 수 없는 타입을 말한다.
- 자바스크립트에서 값을 반환할 수 없는 2가지 예
  - 에러를 던지는 경우
  - 무한히 함수가 실행되는 경우

### 3.1.5 Array 타입

- 타입스크립트에서 배열 타입을 명시하는 것만으로 배열의 길이까지는 제한할 수 없다. 그러나 튜플은 배열 타입의 하위 타입으로 기존 타입스크립트의 배열 기능에 길이 제한까지 추가한 타입 시스템이라고 볼 수 있다.
- 튜플은 배열의 특정 인덱스에 정해진 타입을 선언하는 것과 같다.

### 3.1.6 enum 타입

- enum 타입은 열거형이라고도 부르는데 타입스크립트에서 지원하는 특수한 타입이다.
- 문자열이 아닌 열거형을 타입으로 했을때 얻을 수 있는 효과
  - 타입 안정성
  - 명확한 의미 전달과 높은 응집력
  - 가독성
- 숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있다. 이러한 동작을 막기 위해 const enum으로 열거형을 선언하는 방법이 있다. 이 방식은 역방향으로의 접근을 허용하지 않기 때문에 자바스크립트에서의 객체에 접근하는 것과 유사한 동작을 보장한다.
- 그 외 열거형의 문제
  - 일부 번들러에서 트리쉐이킹 과정 중 즉시 실행 함수로 변환된 값을 사용하지 않는 코드로 인식하지 못하는 경우가 발생할 수 있다. 따라서 불필요한 코드의 크기가 증가하는 결과를 초래할 수 있다.
  - 이러한 문제를 해결하기 위해 const enum 또는 as const assertion을 사용해서 유니온 타입으로 열거형과 동일한 효과를 얻는 방법이 있다.

# Exercise 1

```typescript
export interface User {
  name: string;
  age: number;
  occupation: string;
}

export const users: User[] = [
  {
    name: "Max Mustermann",
    age: 25,
    occupation: "Chimney sweep",
  },
  {
    name: "Kate Müller",
    age: 23,
    occupation: "Astronaut",
  },
];

export function logPerson(user: User) {
  console.log(` - ${user.name}, ${user.age}`);
}

console.log("Users:");
users.forEach(logPerson);
```

unknown으로 지정되어 있으면 user의 프로퍼티에 접근할 때, 어떤 속성이 있는지 알지 못해 오류가 발생가기 때문에 명확하게 User 타입을 재정의한다.
