# 9장 훅

- 상태 정의할 때 타입도 같이 정의해둬라. 안그럼 초기값으로 타입을 추론한다.
- useEffect 의존성 배열은 얕은 비교다. 멍청하게 props에서 받은 객체 데이터 바로 넣지마라
- 자식 컴포넌트에 ref 전달할 때는 `forwardRef` 써라
- `useImperativeHandle` 쓰면 좀 더 유연하게 ref 컴포넌트 작성이 가능하다.

## useRef

`useRef`는 다음과 같이 세 종류의 타입 정의를 가지고 있다.

```tsx
function useRef<T>(initialValue: T | null): RefObject<T>;

function useRef<T = undefined>(): MutableRefObject<T | undefined>;

function useRef<T>(initialValue: T): MutableRefObject<T>;

interface MutableRefObject<T> {
  current: T;
}

interface RefObject<T> {
  readonly current: T | null;
}
```

`useRef`는 `MutableRefObject` 또는 `RefObject`를 반환한다.

### 1. MutableRefObject

- 주로 `DOM` 요소가 아닌 다른 값을 저장할 때 사용된다.
- `MutableRefObject`의 `current`는 값을 변경할 수 있다.
- 다음과 같이 제네릭에 `HTMLDivElment | null`을 넣어준다면 `MutableRefObject`의 `current`는 변경할 수 있는 값이 되어 `ref.current`의 값이 변경되는 사이드 이펙트가 발생할 수 있다.

```tsx
const ref = useRef<HTMLDivElement | null>(null);

const handleTest1 = () => {
  if (ref.current) {
    // ✅ Success
    ref.current = null;
  }
};
```

### 2. RefObject

- `RefObject`의 `current`는 `readonly`로 값을 변경할 수 없다.

```tsx
const testRef2 = useRef<HTMLInputElement>(null);

const handleTest2 = () => {
  if (testRef2.current) {
    // ❌ Cannot assign to 'current' because it is a read-only property.
    testRef2.current = null;
  }
};
```

## 자식 컴포넌트에 ref 전달

함수형 컴포넌트에서 자식 컴포넌트에 `ref`를 일반적으로 전달하면 브라우저에서 경고 메세지를 띄운다.

함수형 컴포넌트는 기본적으로 인스턴스를 생성하지 않는다. 클래스 컴포넌트와 달리 `this` 컨텍스트가 없어, `ref`를 자동으로 할당할 대상이 없다.

그렇기 때문에 `forwardRef`를 사용한다.

### 1. forwardRef

- 첫 번째 인자로는 일반적인 컴포넌트의 `props`를 전달 받는다.
- 두 번째 인자로는 `ref`를 전달 받는다.

```tsx
const MyInput = forwardRef<HTMLInputEIement, Props>((props, ref) => {
  return (
    <div>
      <label>{props.name}</label>
      <input ref={ref} />
    </div>
  );
});
```

### 2. forwardRef 타입

- `forwardRef`의 타입은 다음과 같다.

```tsx
function forwardRef<T, P = {}>(
  render: ForwardRefRenderFunction<T, P>,
): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;

interface ForwardRefRenderFunction<T, P = {}> {
  (props: P, ref: ForwardedRef<T>): ReactNode;

  displayName?: string | undefined;
  defaultProps?: never | undefined;
  propTypes?: never | undefined;
}
```

`ForwardRefRenderFunction`은 2개의 타입 변수 `T`와 `P`를 받는다.

- `P` : 일반적인 컴포넌트에서 자식 컴포넌트로 넘겨주는 `props` 타입
- `T` : `ref`로 전달하려는 요소의 타입. (`ForwardedRef<T>`)

```tsx
// ForwaredRef 타입
type ForwardedRef<T> =
  | ((instance: T | null) => void)
  | MutableRefObject<T | null>
  | null;
```

`useRef`는 `RefObject`와 `MutableRefObject` 타입을 가지고 있다. 하지만 `forwardRef`는 `MutableRefObject` 타입만을 가진다.

그 이유는 `MutableRefObject`의 타입이 `RefObject`보다 넓은 범위의 타입을 가지기 때문에 부모컴포넌트에서 `useRef` 의 타입을 어떻게 선언했냐는 중요하지 않다.

## useImperativeHandle

- `useImperativeHandle`은 `forwardRef`와 함께 사용할 수 있는 훅이다.
- 부모에서 자식 컴포넌트에서 정의한 메서드를 호출할 수 있게 한다. 이는 컴포넌트와의 결합도를 낮춘다.
- 자식 컴포넌트에서 훅을 선언해서 사용한다.

```tsx
import React, {
  forwardRef,
  useRef,
  useImperativeHandle,
  useState,
  useCallback,
} from 'react';

// CustomInput 컴포넌트에 대한 props 타입 정의
interface CustomInputProps {
  label: string;
  onValueChange?: (value: string) => void;
}

// CustomInput 컴포넌트가 외부로 노출할 메서드들의 타입 정의
interface CustomInputHandle {
  focus: () => void;
  blur: () => void;
  clear: () => void;
  setValue: (value: string) => void;
  getValue: () => string;
}

// 자식 컴포넌트
const CustomInput = forwardRef<CustomInputHandle, CustomInputProps>(
  (props, ref) => {
    const [value, setValue] = useState('');
    const inputRef = useRef<HTMLInputElement>(null);

    // 값이 변경될 때 호출되는 핸들러
    const handleChange = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setValue(newValue);
        props.onValueChange?.(newValue);
      },
      [props.onValueChange],
    );

    // useImperativeHandle을 사용하여 외부로 노출할 메서드들을 정의
    useImperativeHandle(
      ref,
      () => ({
        focus: () => {
          inputRef.current?.focus();
        },

        blur: () => {
          inputRef.current?.blur();
        },

        clear: () => {
          setValue('');
          props.onValueChange?.('');
        },

        setValue: (newValue: string) => {
          setValue(newValue);
          props.onValueChange?.(newValue);
        },

        getValue: () => value,
      }),
      [value, props.onValueChange],
    );

    return (
      <div>
        <label>{props.label}</label>
        <input ref={inputRef} value={value} onChange={handleChange} />
      </div>
    );
  },
);

// 부모 컴포넌트
const ParentComponent = () => {
  const inputRef = useRef<CustomInputHandle>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  const handleClear = () => {
    inputRef.current?.clear();
  };

  const handleSetValue = () => {
    inputRef.current?.setValue('Hello, World!');
  };

  const handleGetValue = () => {
    const value = inputRef.current?.getValue();
    alert(`Current value: ${value}`);
  };

  return (
    <div>
      <CustomInput
        ref={inputRef}
        label="Custom Input"
        onValueChange={value => console.log('Value changed:', value)}
      />
      <button onClick={handleFocus}>Focus</button>
      <button onClick={handleClear}>Clear</button>
      <button onClick={handleSetValue}>Set Value</button>
      <button onClick={handleGetValue}>Get Value</button>
    </div>
  );
};

export default ParentComponent;
```

## HTML 요소가 받는 ref 타입

```tsx
<div ref={ref} />
```

`HTML` 요소가 받는 `ref` 타입은 다음과 같다.

```tsx
interface RefAttributes<T> extends Attributes {
  ref?: LegacyRef<T> | undefined;
}

type LegacyRef<T> = string | Ref<T>;

type Ref<T> = RefCallback<T> | RefObject<T> | null;

type RefCallback<T> = {
  bivarianceHack(
    instance: T | null,
  ):
    | void
    | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES];
}['bivarianceHack'];

interface RefObject<T> {
  readonly current: T | null;
}

interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {}
```

HTML에서 `ref`는 다음 4가지 타입을 받는다.

- `string` : 비권장
- `RefCallback<T>` : 콜백함수 ref
- `RefObject<T>` : useRef나 createRef로 생성된 객체
- `null`

<aside>
💡

왜 RefObject<T>

</aside>

- `MutableRefObject`가 더 큰 범위의 타입인데 왜 `RefObject`일까?
- HTML 요소에 `ref`를 할당할 때, React는 이를 `RefObject`로 취급한다고 한다. (클로드 피셜)

이 중에서 `RefCallback<T>`은 특이하게 생겼다.

- `instance: T | null` : `DOM` 요소 또는 `null`을 인자로 받는다.
- `반환값` : `void` 또는 특별한 내부 값 (일반적으로 void를 반환)
- `“bivarianceHack”` : 타입스크립트의 타입 추론을 위한 기술적인 트릭

```tsx
type RefCallback<T> = {
  bivarianceHack(
    instance: T | null,
  ):
    | void
    | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES];
}['bivarianceHack'];
```

<aside>
💡

bivarianceHack ? (클로드 피셜)

</aside>

- 함수 타입의 매개변수에 대해 `이변성`(bivariance)을 적용하기 위한 TypeScript의 특별한 기법이다.
- 이 기법의 주요 목적은 콜백 함수의 매개변수 타입을 더 유연하게 만드는 것이다.
- 이변성은 타입 시스템에서 이변성은 하위 타입과 상위 타입 모두를 허용하는 특성을 말한다.
- 그래서 뭔 효과냐?

  - 매개변수 타입이 정확히 일치하지 않더라도 호환되는 함수를 허용

  ```tsx
  interface Parent {}
  interface Child extends Parent {}

  // bivarianceHack 덕분에 이런 할당이 가능
  const childCallback: RefCallback<Child> = (instance: Parent | null) => {};

  // 좀 더 자세하게는 다음과 같다.

  // RefCallback 타입 (실제 React 타입의 간소화 버전)
  type RefCallback<T> = {
    bivarianceHack(instance: T | null): void;
  }['bivarianceHack'];

  // 범용 포커스 함수
  const focusElement = (element: HTMLElement | null) => {
    element?.focus();
  };

  useEffect(() => {
    // 여기서 bivarianceHack의 효과로 HTMLInputElement 제네릭을 사용했지만
    // HTMLElement를 허용한다.
    const focusInput: RefCallback<HTMLInputElement> = focusElement;
    focusInput(inputRef.current);
  }, []);
  ```

어쨌든 `RefCallback`은 다음과 같이 활용된다.

- `div`가 렌더링되는 시점에 높이를 계산하여 상태를 변경한다.

```tsx
const BasicExample = () => {
  const [height, setHeight] = useState<number | null>(null);

  // callback 선언해주고.
  const measureRef = useCallback((node: HTMLDivElement | null) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <div>
      <div ref={measureRef}>This div's height will be measured</div>
      {height !== null && <p>The div is {height}px tall</p>}
    </div>
  );
};
```

- 여러 요소에 대한 값을 측정할 때도 유용하게 사용될 수 있다.

```tsx
const DynamicElementsExample = () => {
  const [items, setItems] = useState<string[]>(['Item 1', 'Item 2', 'Item 3']);
  const [heights, setHeights] = useState<{ [key: string]: number }>({});

  // 키를 받아서 값을 저장.
  const measureRef = useCallback((node: HTMLLIElement | null, item: string) => {
    if (node !== null) {
      setHeights(prev => ({
        ...prev,
        [item]: node.getBoundingClientRect().height,
      }));
    }
  }, []);

  return (
    <ul>
      {items.map(item => (
        <li key={item} ref={node => measureRef(node, item)}>
          {item}
        </li>
      ))}
    </ul>
  );
};
```

- 주의 사항은 함수가 재선언 될 때마다 실행된다.

<br/>

# 10장 상태 관리

- 서버 상태는 리액트 쿼리 국룰
- 복잡한 상태 다룰 때는 `useReducer` 사용해라
- `context API`를 사용해서 전역 상태 관리는 권장되지 않는 방식이다. 참조 변경될 때마다 구독하고 있는 모든 컴포넌트가 리렌더링.
- 객체의 참조 동일성을 유지하기 위해 `useMemo`를 사용하는 것은 권장되는 방법이 아니다.
- `useRef`로 인스턴스를 생성할 때는 다음과 같이 하는게 좋다.

  ```tsx
  const store = useRef<Store>(null);

  // 렌더링마다 불필요한 인스턴스 생성을 방지한다.
  if (!store.current) {
    store.current = new Store();
  }
  ```

- 컴포넌트 내부에 존재하는 상태를 동기화 하기 위한 `useEffect`는 피해야한다.

<br/>

# 11장 CSS-in-JS

## CSS-in-JS 장점

- `컴포넌트로 생각할 수 있다.`
  - 스타일을 컴포넌트 단위로 추상화하여 생각할 수 있다.
  - 별도의 스타일시트를 유지보수할 필요 없이 각 컴포넌트의 스타일을 관리할 수 있다.
- `부모와 분리할 수 있다.`
  - CSS-in-JS는 부모요소로부터 스타일을 상속 받지 않는다.
  - 각 컴포넌트의 스타일은 부모와 독립되어 동작한다.
- `스코프를 가진다.`
  - 고유한 이름을 생성하여 네임스페이스 충돌을 피해준다.
- `자동으로 벤더 프리픽스가 붙는다.`
  - 자동으로 벤더 프리픽스가 붙어 브라우저 호환성을 향상해준다.
- `자스와 CSS 사이에 상수와 함수를 쉽게 공유할 수 있다.`
  - 변수, 상수, 함수를 스타일 코드 내에서 쉽게 사용할 수 있다.

> **BEM(Block Element Modifier)**

`CSS 클래스 네이밍 컨벤션`의 한 형식을 의미한다. `BEM`은 선택자 충돌과 유지보수 문제를 해결하기 위한 방법론으로 다음과 같은 구조로 클래스명을 작성한다.

- Block
  - 컴포넌트나 모듈의 최상위 레벨 요소를 나타낸다.
  - 클래스 명은 중복되지 않아야 하며, 컴포넌트의 기본 스타일을 정의한다.
- Element
  - 블록 내부의 하위 요소를 나타낸다.
  - 클래스 명은 블록의 클래스 명을 접두어로 가지며 블록 내부에서만 의미가 있다.
- Modifier
  - 블록이나 요소의 상태나 특성을 나타내는 클래스를 추가한다.
  - 특정 상황에 스타일을 변경하거나 동작을 제어할 수 있다.

```tsx
/* Block: 카드 */
.card {
    width: 300px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

/* Element: 카드 제목 */
.card__title {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 10px;
}

/* Modifier: 강조된 카드 제목 */
.card__title--highlighted {
    color: #ff6600;
}

```

> **벤더 프리픽스(Vendor Prefix)**

웹 브라우저마다 지원되는 CSS 속성이나 기능이 다를 때 특정 브라우저에서 제대로 동작하도록 하기 위해 추가되는 접두사를 말한다.

```tsx
 /* 표준 속성 */
    border-radius: 10px;

/* Webkit (Chrome, Safari, newer versions of Opera, Android Browser) */
-webkit-border-radius: 10px;

/* Mozilla Firefox */
-moz-border-radius: 10px;

/* Internet Explorer */
-ms-border-radius: 10px;

/* Opera (old versions) */
-o-border-radius: 10px;
```

## CSS-in-JS 단점

- 별도의 라이브러리 설치
- 런타임 오버헤드
- 서버사이드에서 복잡함
