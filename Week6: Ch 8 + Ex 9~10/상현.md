# 상현

## 8장. JSX에서 TSX로

### 리액트 컴포넌트의 타입

**함수 컴포넌트 타입**

````tsx
/**
 * Represents a JSX element.
 *
 * Where {@link ReactNode} represents everything that can be rendered, `ReactElement`
 * only represents JSX.
 *
 * @template P The type of the props object
 * @template T The type of the component or tag
 *
 * @example
 *
 * ```tsx
 * const element: ReactElement = <div />;
 * ```
 */
interface ReactElement<
  P = any,
  T extends string | JSXElementConstructor<any> =
    | string
    | JSXElementConstructor<any>
> {
  type: T;
  props: P;
  key: string | null;
}

interface Element extends React.ReactElement<any, any> {}

type ReactNode =
  | ReactElement
  | string
  | number
  | Iterable<ReactNode>
  | ReactPortal
  | boolean
  | null
  | undefined
  | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES];
````

함수의 반환타입을 위 3가지로 많이 사용되며 상관괸계로 표현하면 `JSX.Element > ReactElement > ReactNode`순으로 표현 가능

권장되는 사용 방법

- ReactNode는 최상위로 모든 것을 받을 수 있기에 다양한 형태에 적합
- JSX.Element는 ReactElement에 any로 타입을 맞추기에 널럴한 ReactElement에 적합
- ReactElement에는 직접적으로 props를 기재하여 사용처에서 추론 가능하게 사용
  ```tsx
  interface IconProps {
  	size: number;
  }
  interface Props {
  	icon: React.ReactElement<IconProps>
  }
  const Item = ({icon}: Props) => {
  	// number로 추론 가능
  	const iconSize = icon.props.size;
  	return(...)
  }
  ```

**기본 HTML 요소 타입 활용하기**

html요소를 지정할 수 있는 타입으로 두 개가 존재

- `ComponentPropsWithoutRef`
- `DetailedHTMLProps`

사용 차이:

- `DetailedHTMLProps`에는 ref값이 포함이 되어 있고, `ComponentPropsWithoutRef`에는 없다. 따라서, forwardRef를 사용할 경우 `ComponentPropsWithoutRef`를 사용

### 타입스크립트로 리액트 컴포넌트 만들기

**공변성과 반공변성**

> 단, tsconfig의 strictFunctionTypes 옵션이 true 일때의 기준이다. 만일 strict 모드가 아니라면 함수의 매개변수는 이변성을 갖고 있다.

```tsx
// 출처: https://inpa.tistory.com/entry/TS-📘-타입스크립트-공변성-반공변성-💡-핵심-이해하기 [Inpa Dev 👨‍💻:티스토리]
// 공변성 예시: A(좁은 타입)가 B(넓은 타입)의 서브타입이면, T<A>는 T<B>의 서브타입이다
let stringArray: Array<string> = [];
let array: Array<string | number> = [];

array = stringArray; // OK - stringArray는 array를 포함
stringArray = array; // Error

// --------------------------------------------------

let subObj: { a: string; b: number } = { a: "1", b: 1 };
let superObj: { a: string | number; b: number } = subObj; // superObj는 subObj 포함

// subObj <: superObj
// 각각의 프로퍼티가 대응하는 프로퍼티와 같거나 서브타입이어야 한다.
```

```tsx
// 출처: https://inpa.tistory.com/entry/TS-📘-타입스크립트-공변성-반공변성-💡-핵심-이해하기 [Inpa Dev 👨‍💻:티스토리]
// 반공변성: A(좁은 타입)가 B(넓은 타입)의 서브타입이면, T<B>는 T<A>의 서브타입이다.
type Logger<T> = (param: T) => void;

let logNumber: Logger<number> = (param) => {
  console.log(param); // number
};

let log: Logger<string | number> = (param) => {
  console.log(param); // string | number
};

logNumber = log; // OK
log = logNumber; // Error

// 기본적으로 number <: string | number 지만, 함수 매개변수 제네릭에서는 거꾸로
// Logger<string | number> <: Logger<number>
```

## TypeScript Exercise

```tsx
// 9번
interface User {
  type: "user";
  name: string;
  age: number;
  occupation: string;
}

interface Admin {
  type: "admin";
  name: string;
  age: number;
  role: string;
}

type Person = User | Admin;

const admins: Admin[] = [
  { type: "admin", name: "Jane Doe", age: 32, role: "Administrator" },
  { type: "admin", name: "Bruce Willis", age: 64, role: "World saver" },
];

const users: User[] = [
  {
    type: "user",
    name: "Max Mustermann",
    age: 25,
    occupation: "Chimney sweep",
  },
  { type: "user", name: "Kate Müller", age: 23, occupation: "Astronaut" },
];

export type ApiResponse<T> =
  | { status: "success"; data: T }
  | { status: "error"; error: string };

export function requestAdmins(
  callback: (response: ApiResponse<Admin[]>) => void
) {
  callback({
    status: "success",
    data: admins,
  });
}

export function requestUsers(
  callback: (response: ApiResponse<User[]>) => void
) {
  callback({
    status: "success",
    data: users,
  });
}

export function requestCurrentServerTime(
  callback: (response: ApiResponse<number>) => void
) {
  callback({
    status: "success",
    data: Date.now(),
  });
}

export function requestCoffeeMachineQueueLength(
  callback: (response: ApiResponse<number>) => void
) {
  callback({
    status: "error",
    error: "Numeric value has exceeded Number.MAX_SAFE_INTEGER.",
  });
}

function logPerson(person: Person) {
  console.log(
    ` - ${person.name}, ${person.age}, ${
      person.type === "admin" ? person.role : person.occupation
    }`
  );
}

function startTheApp(callback: (error: Error | null) => void) {
  requestAdmins((adminsResponse) => {
    console.log("Admins:");
    if (adminsResponse.status === "success") {
      adminsResponse.data.forEach(logPerson);
    } else {
      return callback(new Error(adminsResponse.error));
    }

    console.log();

    requestUsers((usersResponse) => {
      console.log("Users:");
      if (usersResponse.status === "success") {
        usersResponse.data.forEach(logPerson);
      } else {
        return callback(new Error(usersResponse.error));
      }

      console.log();

      requestCurrentServerTime((serverTimeResponse) => {
        console.log("Server time:");
        if (serverTimeResponse.status === "success") {
          console.log(
            `   ${new Date(serverTimeResponse.data).toLocaleString()}`
          );
        } else {
          return callback(new Error(serverTimeResponse.error));
        }

        console.log();

        requestCoffeeMachineQueueLength((coffeeMachineQueueLengthResponse) => {
          console.log("Coffee machine queue length:");
          if (coffeeMachineQueueLengthResponse.status === "success") {
            console.log(`   ${coffeeMachineQueueLengthResponse.data}`);
          } else {
            return callback(new Error(coffeeMachineQueueLengthResponse.error));
          }

          callback(null);
        });
      });
    });
  });
}

startTheApp((e: Error | null) => {
  console.log();
  if (e) {
    console.log(
      `Error: "${e.message}", but it's fine, sometimes errors are inevitable.`
    );
  } else {
    console.log("Success!");
  }
});

// 10번

interface User {
  type: "user";
  name: string;
  age: number;
  occupation: string;
}

interface Admin {
  type: "admin";
  name: string;
  age: number;
  role: string;
}

type Person = User | Admin;

const admins: Admin[] = [
  { type: "admin", name: "Jane Doe", age: 32, role: "Administrator" },
  { type: "admin", name: "Bruce Willis", age: 64, role: "World saver" },
];

const users: User[] = [
  {
    type: "user",
    name: "Max Mustermann",
    age: 25,
    occupation: "Chimney sweep",
  },
  { type: "user", name: "Kate Müller", age: 23, occupation: "Astronaut" },
];

export type ApiResponse<T> =
  | {
      status: "success";
      data: T;
    }
  | {
      status: "error";
      error: string;
    };

type CallbackBasedAsyncFunction<T> = (
  callback: (response: ApiResponse<T>) => void
) => void;
type PromiseBasedAsyncFunction<T> = () => Promise<T>;

export function promisify<T>(
  fn: CallbackBasedAsyncFunction<T>
): () => Promise<T> {
  return () =>
    new Promise<T>((resolve, reject) => {
      fn((response) => {
        if (response.status === "success") {
          resolve(response.data);
        } else {
          reject(new Error(response.error));
        }
      });
    });
}

const oldApi = {
  requestAdmins(callback: (response: ApiResponse<Admin[]>) => void) {
    callback({
      status: "success",
      data: admins,
    });
  },
  requestUsers(callback: (response: ApiResponse<User[]>) => void) {
    callback({
      status: "success",
      data: users,
    });
  },
  requestCurrentServerTime(callback: (response: ApiResponse<number>) => void) {
    callback({
      status: "success",
      data: Date.now(),
    });
  },
  requestCoffeeMachineQueueLength(
    callback: (response: ApiResponse<number>) => void
  ) {
    callback({
      status: "error",
      error: "Numeric value has exceeded Number.MAX_SAFE_INTEGER.",
    });
  },
};

export const api = {
  requestAdmins: promisify(oldApi.requestAdmins),
  requestUsers: promisify(oldApi.requestUsers),
  requestCurrentServerTime: promisify(oldApi.requestCurrentServerTime),
  requestCoffeeMachineQueueLength: promisify(
    oldApi.requestCoffeeMachineQueueLength
  ),
};

function logPerson(person: Person) {
  console.log(
    ` - ${person.name}, ${person.age}, ${
      person.type === "admin" ? person.role : person.occupation
    }`
  );
}

async function startTheApp() {
  console.log("Admins:");
  (await api.requestAdmins()).forEach(logPerson);
  console.log();

  console.log("Users:");
  (await api.requestUsers()).forEach(logPerson);
  console.log();

  console.log("Server time:");
  console.log(
    `   ${new Date(await api.requestCurrentServerTime()).toLocaleString()}`
  );
  console.log();

  console.log("Coffee machine queue length:");
  console.log(`   ${await api.requestCoffeeMachineQueueLength()}`);
}

startTheApp().then(
  () => {
    console.log("Success!");
  },
  (e: Error) => {
    console.log(
      `Error: "${e.message}", but it's fine, sometimes errors are inevitable.`
    );
  }
);

// In case you are stuck:
// https://www.typescriptlang.org/docs/handbook/2/generics.html
```
