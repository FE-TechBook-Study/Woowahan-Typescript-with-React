# ì„¸ì¤€

## 1. ì¡°ê±´ë¶€ íƒ€ì…

íƒ€ì…ë„ ì¡°ê±´ë¶€ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### extendsì™€ ì œë„¤ë¦­ í™œìš©í•œ ì¡°ê±´ë¶€ íƒ€ì…

- `extends` í‚¤ì›Œë“œëŠ” íƒ€ì…ì„ í™•ì¥í•  ë•Œì™€ íƒ€ì…ì„ ì¡°ê±´ë¶€ë¡œ ì„¤ì •í•  ë•Œ ì‚¬ìš©

- ì œë„¤ë¦­ì—ì„œ `extends` ëŠ” í•œì •ì ì—­í• ë¡œë„ ì‚¬ìš©
- `T extends U ? X : Y`

**ê¸°ë³¸ ì‚¬ìš© ë°©ë²•**

```tsx
type IsString<T> = T extends string ? true : false;

// ì‚¬ìš© ì˜ˆ
type Result1 = IsString<string>; // true
type Result2 = IsString<number>; // false
```

**`ìœ ë‹ˆì˜¨` íƒ€ì…ê³¼ í™œìš©**

```tsx
type NonNullable<T> = T extends null | undefined ? never : T;

// ì‚¬ìš© ì˜ˆ
type Result3 = NonNullable<string | number | null>; // string | number
```

**`ì œë„¤ë¦­`ê³¼ í•¨ê»˜ ì‚¬ìš©**

```tsx
// ì œë„¤ë¦­ê³¼ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ì¡°ê±´ë¶€ íƒ€ì…
type ArrayOrSingle<T> = T extends any[] ? T : T[];

// ì‚¬ìš© ì˜ˆ
type Result4 = ArrayOrSingle<string>; // string[]
type Result5 = ArrayOrSingle<number[]>; // number[]
```

**`infer` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©**

```tsx
// Tê°€ ì„ì˜ì˜ ì¸ìë¥¼ ë°›ê³  ì–´ë–¤ íƒ€ì… Rì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜íƒ€ì…ì¸ì§€ë¥¼ í™•ì¸
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// ì‚¬ìš© ì˜ˆ
function greet(name: string): string {
  return `Hello, ${name}!`;
}

type GreetReturn = ReturnType<typeof greet>; // string
```

**`ë§µë“œ` íƒ€ì… í™œìš©**

```tsx
type Nullable<T> = { [K in keyof T]: T[K] | null };

// ì‚¬ìš© ì˜ˆ
interface User {
  name: string;
  age: number;
}
type NullableUser = Nullable<User>; // { name: string | null; age: number | null; }
```

<br/>

### ì¡°ê±´ë¶€ íƒ€ì…ì„ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ì„ ë•Œì˜ ë¬¸ì œì 

ì¸ìë¡œ ë„£ëŠ” íƒ€ì…ì— ë§ë§ì€ íƒ€ì…ì„ ë°˜í™˜í•˜ê³  ì‹¶ì„ ë•Œ, íƒ€ì… ì„¤ì •ì´ ìœ ë‹ˆì˜¨ìœ¼ë¡œë§Œ ë˜ì–´ ìˆìœ¼ë©´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” í•´ë‹¹ íƒ€ì…ì— ë§ëŠ” ì‘ë‹µ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ì—†ë‹¤.

**ì˜ë„ì¹˜ ì•Šì€ ë™ì‘**

```tsx
// ë¬¸ì œê°€ ìˆëŠ” í•¨ìˆ˜
function getArea(shape: Shape): number | { width: number; height: number } {
  switch (shape.kind) {
    case 'square':
      return shape.size * shape.size;
    case 'rectangle':
      return { width: shape.width, height: shape.height };
    case 'circle':
      return Math.PI * shape.radius * shape.radius;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const square: Square = { kind: 'square', size: 5 };
const rectangle: Rectangle = { kind: 'rectangle', width: 4, height: 6 };
const circle: Circle = { kind: 'circle', radius: 3 };

const squareArea = getArea(square); // number | { width: number; height: number }
const rectangleArea = getArea(rectangle); // number | { width: number; height: number }
const circleArea = getArea(circle); // number | { width: number; height: number }
```

`â€˜sqaure`â€™ì™€ `circle`ì¸ ê²½ìš°ì—ëŠ” `number` íƒ€ì…ì´ ì¶”ë¡ ë˜ëŠ” ê²ƒì„ ì˜ˆìƒí–ˆì§€ë§Œ ì˜ë„ì™€ ë‹¤ë¥´ê²Œ `{ width:number; height: number }`ë„ ê°™ì´ ìœ ë‹ˆì˜¨ìœ¼ë¡œ ì¶”ë¡ í•˜ê²Œ ëœë‹¤.

<br/>

**ì¡°ê±´ë¶€ íƒ€ì… ì‚¬ìš©**

```tsx
// ì¡°ê±´ë¶€ íƒ€ì…ì„ ì‚¬ìš©í•œ ê²½ìš°
type AreaType<T extends Shape> = T extends Square | Circle
  ? number
  : T extends Rectangle
  ? { width: number; height: number }
  : never;

function getAreaImproved<T extends Shape>(shape: T): AreaType<T> {
  switch (shape.kind) {
    case 'square':
      return (shape.size * shape.size) as AreaType<T>;
    case 'rectangle':
      return { width: shape.width, height: shape.height } as AreaType<T>;
    case 'circle':
      return (Math.PI * shape.radius * shape.radius) as AreaType<T>;
  }
}

// ê°œì„ ëœ ì‚¬ìš© ì˜ˆì‹œ
const squareAreaImproved = getAreaImproved(square); // number
const rectangleAreaImproved = getAreaImproved(rectangle); // { width: number; height: number }
const circleAreaImproved = getAreaImproved(circle); // number
```

ì¡°ê±´ë¶€ íƒ€ì…ì„ ì‚¬ìš©í•˜ë‹ˆ ì˜ë„í•œëŒ€ë¡œ ì•Œë§ì€ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤. ì´ì²˜ëŸ¼ ì¡°ê±´ë¶€ íƒ€ì…ì€ ë¶ˆí•„ìš”í•œ `íƒ€ì… ê°€ë“œ`, `íƒ€ì… ë‹¨ì–¸` ë“±ì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

### inferë¥¼ í™œìš©í•œ íƒ€ì… ì¶”ë¡ 

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `infer`ëŠ” íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ì—­í• ì„ í•œë‹¤.

```tsx
// Tê°€ Promise<K>ë¥¼ ë°˜í™˜í•˜ëŠ” ë°°ì—´ì´ë¼ë©´ Kì˜ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

---

## 2. í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì… í™œìš©

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” ìœ ë‹ˆì˜¨ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ íƒ€ì…ì„ íŠ¹ì • ë¬¸ìì—´ë¡œ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

ì´ ë•Œ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ì„ ì‚¬ìš©í•˜ë©´ ì½”ë“œë¥¼ ì¬ì‚¬ìš©í•˜ê³  ìˆ˜ì •í•˜ëŠ” ë° ìš©ì´í•œ íƒ€ì…ì„ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.

```tsx
type HeadingNumber = 1 | 2 | 3 | 4 | 5;
type HeaderTag = `h${HeadingNumber}`; // "h1" | "h2" | "h3" | "h4" | "h5"
```

<aside>
ğŸ’¡ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ ì‚¬ìš©ì‹œ ì£¼ì˜í•  ì 

</aside>

- ìœ ë‹ˆì˜¨ì€ íƒ€ìŠ¤ ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ë¡ í•  ë•Œ ì˜¤ë˜ ê±¸ë¦¬ë©´ ë¹„íš¨ìœ¨ì ì´ê¸° ë•Œë¬¸ì— ì—ëŸ¬ë¥¼ ë‚´ë±‰ì„ ë•Œê°€ ìˆë‹¤.
- íƒ¬í”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ì— ì‚½ì…ëœ ìœ ë‹ˆì˜¨ì˜ ì¡°í•©ì´ ë§ì€ ê²½ìš° ì ì ˆí•˜ê²Œ ë‚˜ëˆ„ì–´ì•¼ í•œë‹¤.

---

## 3. ì»¤ìŠ¤í…€ ìœ í‹¸ë¦¬í‹° íƒ€ì… í™œìš©

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” ìœ í‹¸ë¦¬í‹° íƒ€ì…ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ë° í•œê³„ë¥¼ ëŠë‚€ë‹¤ë©´ ì»¤ìŠ¤í…€ ìœ í‹¸ë¦¬í‹° íƒ€ì…ì„ êµ¬í˜„í•´ë³´ì.

### PickOne êµ¬í˜„

ì£¼ì–´ì§„ íƒ€ì… `T`ì—ì„œ ì •í™•íˆ í•˜ë‚˜ì˜ ì†ì„±ë§Œì„ ì„ íƒí•˜ë„ë¡ ê°•ì œí•˜ëŠ” íƒ€ì…ì„ êµ¬í˜„í•´ë³´ì.

```tsx
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> &
    Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
```

- `[P in keyof T]`
  - `T`ì˜ ëª¨ë“  í‚¤ì— ëŒ€í•´ ë£¨í”„ëˆë‹¤.
- `Record<P, T[P]>`
  - í˜„ì¬ í‚¤ `P`ì™€ ê·¸ ê°’ì˜ íƒ€ì… `T[P]`ë¥¼ ê°€ì§„ ë ˆì½”ë“œë¥¼ ìƒì„±í•œë‹¤.
- `Partial<Record<Exclude<keyof T, P>, undefined>>`
  - í˜„ì¬ í‚¤ `P`ë¥¼ ì œì™¸í•œ ëª¨ë“  í‚¤ë¥¼ ì˜µì…”ë„ `undefined`ë¡œ ë§Œë“ ë‹¤.

**ì˜ˆì‹œ**

```tsx
// PickOne íƒ€ì… ì •ì˜
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> &
    Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];

// ì˜ˆì œ ì¸í„°í˜ì´ìŠ¤
interface Options {
  a: string;
  b: number;
  c: boolean;
}

// PickOne ì‚¬ìš© ì˜ˆì œ
type PickOneOption = PickOne<Options>;

// ì˜¬ë°”ë¥¸ ì‚¬ìš© ì˜ˆ
const option1: PickOneOption = { a: 'test' };
const option2: PickOneOption = { b: 42 };
const option3: PickOneOption = { c: true };

// Error ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ ì˜ˆ (ë‘ ê°œ ì´ìƒì˜ ì†ì„± ì„ íƒ)
const invalidOption: PickOneOption = { a: 'test', b: 42 };

// Error ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ ì˜ˆ (ì†ì„± ì—†ìŒ)
const emptyOption: PickOneOption = {};

// í•¨ìˆ˜ì—ì„œì˜ ì‚¬ìš© ì˜ˆ
function processOption(option: PickOneOption) {
  if ('a' in option) {
    console.log('Option A selected:', option.a);
  } else if ('b' in option) {
    console.log('Option B selected:', option.b);
  } else if ('c' in option) {
    console.log('Option C selected:', option.c);
  }
}

// í•¨ìˆ˜ í˜¸ì¶œ ì˜ˆ
processOption({ a: 'Hello' });
processOption({ b: 100 });
processOption({ c: false });
```

---

## 4. ë¶ˆë³€ ê°ì²´ íƒ€ì… í™œìš©

`as const`ë¡œ ê°ì²´ë¥¼ ë¶ˆë³€ ê°ì²´ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.

---

## 5. Record ì›ì‹œ íƒ€ì… í‚¤ ê°œì„ í•˜ê¸°

`Record`ì˜ í‚¤ë¥¼ ì›ì‹œ íƒ€ì…ìœ¼ë¡œ ì„¤ì •í–ˆì„ ë•Œì˜ ë¬¸ì œì ì— ëŒ€í•´ ì•Œì•„ë³´ì

### ë¬´í•œí•œ í‚¤ë¥¼ ì§‘í•©ìœ¼ë¡œ ê°€ì§€ëŠ” Record

```tsx
type Category = string;

interface Food {
	name:string;
	...
}

const foodByCategory: Record<Category, Food[]> = {
	'í•œì‹' : [...],
	'ì¼ì‹' : [...]
};

// ë¬¸ì œ ë˜ëŠ” ìƒí™©
foodByCategory["ì–‘ì‹"]; // Food[] ì¶”ë¡ 
foodByCategory["ì–‘ì‹"].map(...) // ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ.
```

`Record<Category, Food[]>`ëŠ” `Record<string, Food[]>`ì™€ ë™ì¼í•˜ê¸° ë•Œë¬¸ì— ë¬´í•œí•œ í‚¤ ì§‘í•©ì„ ê°€ì§€ê²Œ ëœë‹¤.

### ìœ ë‹› íƒ€ì…ìœ¼ë¡œ ë³€ê²½í•˜ê¸°

```tsx
type Category = "í•œì‹" | "ì–‘ì‹";

interface Food {
	name:string;
	...
}

const foodByCategory: Record<Category, Food[]> = {
	'í•œì‹' : [...],
	'ì¼ì‹' : [...]
};

// ì–‘ì‹ì€ Record<Category, Food[]>ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì—ëŸ¬ ë°œìƒ
foodByCategory["ì–‘ì‹"];

```

ì´ì²˜ëŸ¼ ìœ ë‹› íƒ€ì…ì„ í™œìš©í•˜ë©´ ê°œë°œ ì¤‘ì— ìœ íš¨í•˜ì§€ ì•Šì€ í‚¤ê°€ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

í•˜ì§€ë§Œ í‚¤ê°€ ë¬´í•œí•´ì•¼ í•˜ëŠ” ìƒí™©ì—ëŠ” ì í•©í•˜ì§€ ì•Šë‹¤.

### Partialì„ í™œìš©í•˜ì—¬ ì •í™•í•œ íƒ€ì… í‘œí˜„

í‚¤ê°€ ë¬´í•œí•œ ìƒí™©ì—ì„œëŠ” `Partial`ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ê°’ì´ `undefined`ì¼ ìˆ˜ ìˆëŠ” ìƒíƒœì„ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

ê°ì²´ ê°’ì´ `undefined`ì¼ ìˆ˜ ìˆëŠ” ê²½ìš°ì— `Partial`ì„ ì‚¬ìš©í•´ì„œ `PartialRecord` íƒ€ì…ì„ ì„ ì–¸í•˜ê³  ê°ì²´ ì„ ì–¸ ì‹œì— í™œìš©í•œë‹¤.

```tsx
type PartialRecord<K extends string, T> = Partial<Record<K,T>>
type Category = string;

interface Food {
	name:string;
	...
}

const foodByCategory: PartialRecord<Category, Food[]> = {
  í•œì‹: [{ name: "ì œìœ¡ë®ë°¥" }, { name: "ë–¡ë³¶ì´ ë³¶ìŒë°¥" }],
  ì¼ì‹: [{ name: "ì´ˆë°¥" }, { name: "í…ë™" }],
};

foodByCategory["ì–‘ì‹"]; // Food[] ë˜ëŠ” undefined íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 

foodByCategory["ì–‘ì‹"].map((food) => console.log(food.name)); // Object is possibly 'undefined'

foodByCategory["ì–‘ì‹"]?.map((food) => console.log(food.name)); // OK
```

`Record`ë¥¼ `Partial`ë¡œ ë§¤í•‘í•´ì£¼ì–´ `foodByCategory[key]`ë¥¼ `Food[] | undefined`ë¡œ ì¶”ë¡ í•œë‹¤.

ê°œë°œìëŠ” ì´ë¥¼ í†µí•´ `ì˜µì…”ë„ ì²´ì´ë‹`ì„ ì‚¬ìš©í•˜ê±°ë‚˜ `ì¡°ê±´ë¬¸`ì„ ì‚¬ìš©í•˜ëŠ” ë“± ì‚¬ì „ì— ì¡°ì¹˜í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.
